{"posts":[{"title":"贪心","content":"1472F 从左到右考虑每一列， 确定了前 i−1i-1i−1 列，那么现在的第 iii 列哪些被覆盖就确定了。 可以求出第 iii 列覆盖的方案：如果没有空格/只有一个空格，则只能放横的；否则两个都是空格，一种是放两个横的，一种是放一个竖的，可以发现放两个横的和放两个竖的等价，不如变成放竖的，其它的之后再决策。 所以就变成，只要这一列没满，就横着放，否则竖着放。 有一种离谱情况，它是第一行放(1,2),(3,4),...，第二行放的是(2,3),(4,5),...，类似于这种就必须横着放。 那么你就可以O(m)模拟，你这一列覆盖完之后就知道后面的是上下两行差1的情况还是可以直接竖着放。 从有障碍的一列到后一个有障碍的一列，中间快速跳。 1367F 我们直接来做F2。首先可以离散化，然后发现每个数最多操作一次，不然你可以只操作最后的那一次。 根据经典套路，你把不动的拿出来，一定是个递增序列，剩下的也得能归位（比最小值小或比最大值大，也就是&gt;最小&lt;最大的必须本身在序列内）。 直接设 dp[i]dp[i]dp[i] 表示 iii 选了且是最大的最长长度，a[i]=xa[i]=xa[i]=x。一种从之前的最后一个 xxx 转移过来；一种是选所有的 x−1x-1x−1（必须在 iii 前面），再从第一个 x−1x-1x−1 转移过来；还有一种是选之前所有的 x−1x-1x−1。 分别求出来转移即可。 1373E（#） 考虑 x+kx+kx+k 进没进位。 如果没进位，枚举最后一位，之前的位贪心（尽量填9）。 如果进位了，枚举最后一位和之前连续的9的长度，计算一下，再贪心（先填一个8，再尽量填9）。 1530E（#） 如果只有一种字符，那只有一种方法，直接结束。 f为0：如果有某种字符只出现一次，那么拿最小的只出现一次的字符当开头，其它的从小到大往后排（不可能拿出现果不止一次的字符，那会使得f至少为1；也不可能取更大的字符，那字典序更大）。 f为1：现在所有字符都出现至少两次（这种情况答案一定不为0，不妨假设a出现了），想让字典序尽量小，先考虑有没有可能是以aa开头，那么之后就不能有两个相邻的a（否则f至少为2），只能形如aababa…ca…。可以发现a的个数最多为其它数字个数+2，即cnt&gt;=n-cnt+2，cnt&gt;=n/2+1。 如果不满足条件（不妨假设b出现了），考虑开头为ab，那么之后就不能再出现ab，如果只有两种字符，那么b一定要出现在a前面，即abbb…baa…a；如果有更多字符（不妨假设c出现了），那么可以为abaaa…acbbb...bccc…c…，即ab之后填所有的a，再填c，剩下的从小到大填。 1254B2（#） 只需要考虑 kkk 是质数的情况。 其实 aia_iai​ 和 ai mod ka_i \\bmod kai​modk 是完全等价的（不会出现负数啥的情况），那么前面往后移和后面往前移也是等价的，计算一下答案即可。 576C（#） 按照莫队的方法奇偶排序即可。 547A（#） 你先暴力跳，把第一个跳满足，如果跳了 mmm 次还不满足就无解。 如果此时第二个也满足就直接结束。 否则你让第一个就再跳一个环回，跳回来，记录此时第二个乘的x和加的y。 之后再跳第一个就不变了，依旧暴力跳，不超过m次。 1253E 对于原问题，可以加入一个 [0,0] 的区间，这样不会影响答案（可以把第二个区间多扩展这个区间的范围）。 设 dpidp_idpi​ 表示只用中心不超过 iii，覆盖 1..i1..i1..i 的最小代价。有了 [0,0][0,0][0,0] 就不存在不能覆盖的问题了。 如果原先覆盖了 ii i 那么从之前没覆盖的第一个位置转移，否则直接考虑之前的某一个扩展到 iii，再从左端点之前转移过来。 但是你可以扩展得更长，多覆盖左边的一点，这样就很麻烦了。但是 dpi+1≤dpi+1dp_{i+1}\\leq dp_i+1dpi+1​≤dpi​+1，你可以把之前的区间增加 111。 1316E 排序，变成 aia_iai​ 从大到小排序。 范围很小，直接状压 dpdpdp 记录到哪一个，之前队伍有了哪几个位置（状态），有多少名观众。 如果当前放进队伍就枚举放哪个位置，不放进队伍如果观众不够就当观众，否则就不参加。 1296F（#） 显然要满足 u,vu,vu,v 路径上的边权都 ≥w\\geq w≥w。 路径取 max⁡\\maxmax 后判断是否合法即可。 1334E（#） 考虑路径会长成什么样，直观的想法是先除后乘一定严格比先乘后除优，不妨反证。考虑从x到x*p/q。 设p,q为两个不等质数，先乘后除：-d(x)+d(xp)+d(xp)-d(xp/q)，先除后乘：d(x)-d(x/q)-d(x/q)+d(xp/q) 要求-d(x)+d(xp)+d(xp)-d(xp/q)&lt;=d(x)-d(x/q)-d(x/q)+d(xp/q)，整理得2d(x)-2d(xp)+2d(xp/q)-2d(x/q)&gt;0. 都除以2，移项变成d((x/q)p)-d(x/q)&gt;=d(xp)-d(x)，可以知道，*p之后增加量应该数字除去所有p之后，剩下的因子数，(x/q)|x，这个式子一定不成立。（为啥不考虑p=q呢，因为边权一定为正，没必要从x到x）。 所以一定会先除后乘，否则可以交换顺序。那么可以变成x一直除，y一直除，到达同一个点。 由于你只是除，那么路径上的中间点的权值都会删去，所以路径长度一定是d(x)-d(目标点)。 那么答案是d(x)+d(y)-2d(目标点)，x,y都能到达的点只能是g=gcd(x,y)的约数，可以发现g的约数中，g本身的d(g)是严格最大的，所以目标点也固定为g。答案就是x到g的方案数*y到g的方案数。 相当于要求一个数x，每次除一个质因数，有多少种不同的方法，那么就用tot!/(p1!p2!...pk!)算算多重组合。 由于题目说了给的都是D的约数，先求出D的所有质因子，询问的时候就可以O(log V)解决。 1384B2（#） 称无论什么时候在当前位置都是安全的点为安全点，否则为不安全点。显然不安全点能走的时间是一些区间。 若当前点为安全点且下一个点也是安全点，直接走过去即可； 若当前点为安全点且下一个点不是安全点，则在最优的时间走过去（递减且正好能走过去）。 若当前点不为安全点且下一个点是安全点，直接走过去即可； 若当前点不为安全点且下一个点不是安全点，则只要能走过去且不死就走过去，一直不走必定会死，能跑路就赶紧跑路。 549G（#） 继续寻找不变量，ai+ia_i+iai​+i 总是不变的。 初始的 ai+=ia_i+=iai​+=i，条件变为：ai−1≥aia_{i-1}\\geq a_iai−1​≥ai​ 的话交换 ai−1,aia_{i-1},a_iai−1​,ai​。 如果有相等的显然最后会一直交换，否则最后会排序，再 −i-i−i 输出即可。 825E（#） 你直接按照顺序拓扑排序，把小的给编号小的，求出的是答案对应的逆排列最小。（编号小的其实是越早经过越优）。 非常有意思的一点是，你如果建反图，尽量把大的给编号大的，这样求出的就是答案最小。（现在越早经过反而变成越劣，反过来了）。 1411D（#） 把贡献分成几种情况，0和1，?和1，0和?，?和?。 可以知道，把序列分成若干部分，它们之间形成的01/10子序列和内部顺序无关。 考虑?...?，它们和外部的贡献和顺序无关，和0,1出现次数有关。如果?替换从0,0或1,1的出现次数不同。 替换成0,1和1,0出现次数相同，内部的贡献比较变为0...1和1...0哪个大，设中间的...有a个0，b个1，那么0,1的贡献是(a+b+1)x，1,0的贡献是(a+b+1)y，看x,y哪个大变成哪个即可。 不妨设x比较大，所以?填的一定是前面若干个0，后面若干个1，枚举前面多少个填0，可以计算出?和?，而其它三种预处理即可。 1154F 可以发现一定选最便宜的 kkk 双，因为如果选了 xxx 有一个更小的 yyy 没选，那么如果本身 xxx 被免费，那么换成 yyy 之后一定也免费；如果 xxx 不免费，一种是换成 yyy 之后也不免费，一种是换了变免费了，那么有一个变收费了，变收费的一定比 xxx 小，总代价也变小。 排序。总和固定，你希望免费的鞋的钱的价格尽量高，所以你会成段成段的买。 然后dp，枚举最后一次买了多少双鞋，计算一下代价。 1535E 这题关键在于： 保证 ci&gt;cpic_i&gt;c_{p_{i}}ci​&gt;cpi​​，所以删的一定是到根路径上的前缀； 操作是有后效性的（永久的）。 删的一定是到根路径上的一个前缀，删除的时间可以均摊。 怎么找最上面的点？考虑倍增（主要是方便在线加点），找到最上面没被删的点即可。 1154G（#） 拿个桶记录每个数有没有出现过。 lcm可能很大，但lcm(a,b)=ab/gcd(a,b)，考虑枚举gcd和它的倍数，求两个最小的出现过的更新答案即可。 1556E 可以发现，设 ci=bi−aic_i=b_i-a_ici​=bi​−ai​，那么就变成选出下标递增的 kkk 个位置 −1,+1,−1,+1,...,−1,+1-1,+1,-1,+1,...,-1,+1−1,+1,−1,+1,...,−1,+1，要求所有数都是 000。 显然和不变，所以和必为 000 才有解。根据经典套路，做个前缀和还是要求所有数都是 000，就变成区间 −1-1−1（最后一个数不能动，也说明和必须为 000），如果原先有负数显然无解。 由于每次可以任意选区间，所以答案就是最大值。 先全局做一次，维护一下区间最大最小值，再都减去 l−1l-1l−1 的前缀和，如果最小值 &lt;0&lt;0&lt;0 则无解，再判断 rrr，如果是 000 也无解，最后再输出最大值。 1494D（#） LCA 的权值为最大值的，说明它们 LCA 为根。 LCA 的权值不为最大值的，说明它们在根节点同一子树。 递归下去即可。 1557D 设 fif_ifi​ 表示 1..i1..i1..i 行能选出多少行使得选出的数量最多（第 iii 行必选）。 如果第 iii 行和第 j(j&lt;i)j(j&lt;i)j(j&lt;i) 行能相邻，fif_ifi​ 就可以从 fj+1f_j+1fj​+1 转移。 判相邻就看是否有一列相交，不妨转变思路，直接把有第 xxx 列的放到线段树上取最大值，求 fif_ifi​ 就在 iii 有的区间上取最大值即可。 答案是 n−max⁡fin-\\max f_in−maxfi​。 1605D 首先看条件 u⊕v≤min(u,v)u \\oplus v\\leq min(u,v)u⊕v≤min(u,v)，不妨设 u&lt;vu&lt;vu&lt;v，如果 u,vu,vu,v 最高位不同，那么 u⊕vu\\oplus vu⊕v 的最高位就是 vvv 的最高位，比 uuu 大，矛盾。如果最高位相同，直接异或掉了，一定满足。 所以条件就变为 u,vu,vu,v 最高位相同。由于是轮流操作，你还可以把树黑白染色。 显然所有点都不能动的构造最大。看黑白两边的节点个数 x,yx,yx,y，不妨设 x≤yx\\leq yx≤y。 最高位不同的数之间相互独立，把 xxx 二进制分解，最高位是那些的都放到 xxx，剩下的都放到 yyy。 那么所有点相邻的都没有同最高位的，所以都不能走。 1175E 用一个区间覆盖第 iii 个点，假设之前都覆盖了，那么右端点一定越靠右越好。 求出覆盖第 iii 个点的右端点最右的区间，扫一遍取 max⁡\\maxmax，建边指向右端点右边那个点。 现在变成一个森林， 从 lll 开始跳几步才能 ≥r\\geq r≥r，倍增即可。 1271D 对于一个城堡，你一定尽量晚的放士兵，因为如果你之前不放后来放， 影响是中间那一段时间军中的人数增加 111，不会更劣。 由于你会走过每一个城堡，记录哪些是在这个城堡才会选的驻守方案，如果不往那些驻守之后就守不了了。 直接二维 dpdpdp 记到哪一个还有多少人是一定可以的。不这么做，考虑带悔贪心。 因为你必须走到底，所以你可以先在最后能驻守的时候先驻守，行军人数不够就反悔把之前的抽出来，但是你走过去之后，就不能把这些人放回去了（他们必须跟过来），所以复杂度是对的。 1220E（#） 因为保证了图连通，考虑拓扑排序。 排序完之后剩下的还在图中的，它们一定可以一次走完并且停在任何一个点。 就分进入环还是不进入环的情况，可以（对被删去的点）处理一个f数组表示从度数为0的点开始到这个点的最大权值，同时更新不经过环的答案，最后把不删的点之和+f的最大权值。 1404C（#） 如果询问的是整个序列，那么每次删除最后一个满足 ai=ia_i=iai​=i 的位置即可，把删除顺序记作 bib_ibi​。 询问的不是整个序列，找第一个 bi&lt;xb_i&lt;xbi​&lt;x，在之前的 bi≤yb_i\\leq ybi​≤y 的都对答案产生了 111 的贡献，计算即可。 1511E 横着的和竖着的是独立的，横/竖的极长连续段之间也是独立的。 如果有一段长度为 xxx 的横/竖的极长连续段，设它的答案为 f[x]f[x]f[x]，那么对应的贡献为 f[x]∗2tot−xf[x]*2^{tot-x}f[x]∗2tot−x（tottottot 是总白色格子数量，即剩下可以任意选）。 考虑 f[i]f[i]f[i] 的转移： iii 位置是另一种颜色，从 f[i−1]f[i-1]f[i−1] 转移过来； iii 位置是这种颜色，i−1i-1i−1 不是这种颜色，从 f[i−2]f[i-2]f[i−2] 转移过来； iii 位置是这种颜色，i−1i-1i−1 也是这种颜色，从 f[i−2]+2i−2f[i-2]+2^{i-2}f[i−2]+2i−2 转移过来（后面加的是之前的方案数）。 横竖都算一边加起来即可。 1029E（#） 看上去比较像贪心，首先新的边一定一端是1，否则不优（你是要减小最短路，看减小的是哪边，不妨把另一边换成1）。考虑哪些点的策略一定是固定的。 考虑一个还不满足条件的叶子节点，那么一定要把它或它的父亲和1连边，连谁比较优呢。 发现一定会连它的父亲，它父亲会使得满足条件的更多，且除了它本身以外其它点的最短路更小。 对于满足条件的叶子节点，可以发现能把其删掉，选它也不如选它的父亲。 所以你每次选一个深度最深的叶子节点做，然后删去，更新它父亲的深度。 767B 你考虑，如果你要在前面一些老哥之后，这个老哥之前， 那么你在之前的任何时间点来和后面这个老哥来的前一秒来是没区别的。 所以你就对于每个老哥，看在这个老哥前一秒来要等多少时间（等不等得到，now+m&gt;Tenow+m&gt;T_enow+m&gt;Te​ 就等不到了）。之前要占多少时间可以直接拿个数字记录，即之前的人都走完需要多久，减一下更新答案。 1415E（#） 相当于分成最多k+1个序列，每个序列再按照顺序计算。 可以贪心考虑，显然分出的每个序列都是从大到小排序最好。 用堆维护每个序列当前的和，找到最大的序列加上当前的数。 679B 考虑能不能变成规模更小的子问题。 求出最大的 xxx 满足 x3≤nx^3\\leq nx3≤n，那么最后答案中，第一步取的一定不超过 xxx。 如果第一步取 xxx，那么剩下的可以是 [0,n−x3][0,n-x^3][0,n−x3] 中的任何数（初始在 [x3,n][x^3,n][x3,n]）。 如果第一步取 x−1x-1x−1，那么剩下的可以是 [0,x3−1−(x−1)3][0,x^3-1-(x-1)^3][0,x3−1−(x−1)3] 中的任何数（初始在 [(x−1)3,x3−1][(x-1)^3,x^3-1][(x−1)3,x3−1]）。 初始取比 x−1x-1x−1 更小的一定不如取 x−1x-1x−1，剩下的范围更大。 那么也就是说能递归到 max⁡(n−x3,x3−1−(x−1)3)\\max(n-x^3,x^3-1-(x-1)^3)max(n−x3,x3−1−(x−1)3) 的子问题，nnn 的答案是它的答案 +1+1+1。 不过比较低素质的是相同的情况下让体积最大，所以你求出答案之后还得看到底取哪边可以，都可以就尽量取大的。 这个递归复杂度是 O(n13)O(n^{\\frac 13})O(n31​)。 1528C 可以发现，第一棵树取得一定是祖孙链。 在两棵树上都保证了 fai&lt;ifa_i&lt;ifai​&lt;i，所以你枚举第一棵树的祖孙链的时候，如果第二棵树的这个点和之前的点（最多只有一个）有祖孙关系，一定用这个点替代之前的点（dfsdfsdfs 序的区间严格被之前的包含）。 1396C 由于 r1≤r2≤r3r_1\\leq r_2\\leq r_3r1​≤r2​≤r3​，而手枪和AWP都只能打一只怪物，所以AWP只可能用来打BOSS。 如果用手枪一只一只打小怪，最后一定是一起把BOSS一起解决了（不解决放着之后需要的时间不会更少）。 如果用激光枪，那么打完一定要走，如果之前 i−1i-1i−1 BOSS也没死，就去打 i−1i-1i−1，否则打 i+1i+1i+1（你之后还得打 i−1i-1i−1 的BOSS，不如现在先去了）。 不过即使你用手枪打， 如果 i−1i-1i−1 的BOSS没死，你打完后一定也是先去 i−1i-1i−1，之后再折返一定不优。 所以说，假设 iii 之前的怪全都死了，一种是你用手枪+AWP解决，到 i+1i+1i+1；另一种是用激光枪/手枪给每个打一枪，然后到 i+1i+1i+1，再用任意方法（都打一枪或直接解决），再回到 iii，手枪一枪打死BOSS，又到 i+1i+1i+1，如果BOSS没死也一枪打死，最后到 i+2i+2i+2。 所以一种是新增 ai×r1+r3+da_i\\times r_1+r_3+dai​×r1​+r3​+d 的代价走到 i+1i+1i+1，一种是新增 min⁡((ai+1)×r1,r3)+r1+min⁡(min⁡((ai+1+1)×r1,r3)+r1,ai+1×r1+r3)+4d\\min((a_i+1)\\times r_1,r_3)+r_1+\\min(\\min((a_{i+1}+1)\\times r_1,r_3)+r_1,a_{i+1}\\times r_1+r_3)+4dmin((ai​+1)×r1​,r3​)+r1​+min(min((ai+1​+1)×r1​,r3​)+r1​,ai+1​×r1​+r3​)+4d走到 i+2i+2i+2。 dp即可。 675E 从后往前维护后缀最大值（是指 i..j−1i..j-1i..j−1 中的所有值都比 a[j]a[j]a[j] 小）。 那么你从这个点开始， 走到的点一定在这个点开始的后缀最大值的集合内。 而且，后缀最大值也不一定会出现，如果这个点能直接走到下下个点，那么下一个点也没用了。 用单调栈维护这个集合，同时维护这个集合中的位置之和来计算答案。 1202C 行列独立，分别处理，以行为例：先求不操作得到的最小/最大值。 现在要让最大值-1（或最小值+1）,显然当当前值第一次等于最大值（最小值）的时候必须是有-1（+1）。 然后更新操作后的最小最大值，列同理。再计算一下。 1203F2 同F1，加血的没区别（按照 aia_iai​），扣血的你利用调整法，发现也差不多，按照 ai+bia_i+b_iai​+bi​ 的顺序从大到小。 加血显然能加就加，扣血的现在可以选择扣不扣，跑个背包即可。 1108F（#） 和MST有关的，很多贪心都是对的。。。 随便取一棵生成树，不妨假设最后留下的就是这棵生成树。 那么你对于剩下的非树边，和树边一定形成了一个环，它不能替换环上的其它边，即要比其它边都严格大。 考虑边kruskal边计算答案，发现后面加入的边如果需要增加当且仅当在加入同权值的边之前是不连通的，加了同权值的边后连通，为了不让自己替换那条边所以要+1。 同权值的一起计算即可。 754D 按照左端点从小到大排序。 把右端点加入小根堆，每次弹堆顶保证不超过 k 个数。 如果有 k 个那么用最小值-当前左端点+1更新答案。 1152D 你考虑类似二分图匹配，左部是深度为奇数的点，右部为深度为偶数的点。 答案不超过两部大小较小值。容易构造出答案为左部大小的答案， 即每个深度为奇数的点选一个儿子（一定能选出）。 按照左端点从小到大排序。 把右端点加入小根堆，每次弹堆顶保证不超过 k 个数。 如果有 k 个那么用最小值-当前左端点+1更新答案。 976E 明显*2只给同一个人最优。 剩下的一定是选替换掉新增的贡献最大的若干个。 排序求一下即可。 1398E（#） 设电的数量为x。可以发现，理想的情况是你给最大的x个翻倍。 但是有可能不行，因为可能最大的x个都是电，这样一定有一个翻不了，可以发现一定不翻最小的。 而且，如果最大的x个中有火，你就从一个不用翻的电开始就可以了，此时一定没有最小的电。 所以无论什么情况，都不会翻最小的电。你要求的是答案尽量大。 如果x大有火则为S+S1，否则为S+S2-M（S为所有和，S1为前x大和，S2为前x+1大和，M为最小的电）。 可以用set维护前x+1大，相同的认为火更大。 708C（#） 以你要的点为根，你要让所有子树都&lt;=n/2，如果本身满足就不用操作，否则你需要在&gt;n/2的子树里找到一个&lt;=n/2的最大子树拿出来直接接到根上，如果拿出了这个子树之后就&lt;=n/2了的话就OK。 考虑固定了根怎么求，可以dp，设dp[u]表示u子树里最大的&lt;=n/2的子树，转移就是看所有儿子，如果size不超过n/2就用size转移，否则用dp转移，取个最大值。 只记最大的其实也不行，因为你要换根，换根了之后就要把某个儿子的贡献去掉，所以记最大的和次大的，如果往最大的子树换根则这个点的值变为次大的，否则就是最大的。 767D 一组牛奶可以当且仅当 iii 天内过期的牛奶不超过 k×ik\\times ik×i 瓶。 一定会买保质期最长的若干瓶， 把商店里的牛奶按保质期从大到小排序。 现在考虑到第 xxx 瓶牛奶，维护后面前缀和-k×ik\\times ik×i 的最小值，就能知道这瓶牛奶放不放的下，放不下就结束，否则就放，最小值-1，到下一瓶牛奶更新中间的最小值。 1537F（#） 这种就考虑生成树或二分图。按照经典套路，每次加或减的都是一个偶数，所以如果和的奇偶性不对显然无解。 可以发现，能把两个距离为奇数的位置一个+1一个-1，能把两个距离为偶数的位置都+1/-1。 如果有奇环，因为原图连通，故任意两点都存在长度为奇数/偶数的路径，故一定有解。 如果没有奇环，那么是二分图，那么左部之和减右部之和不变，判断一下即可。 1213F（#） 如果 pl..rp_{l..r}pl..r​ 形成的可重集= ql..rq_{l..r}ql..r​ 形成的可重集，那么可以使用同一种字符来填。 固定了 lll，那么尽量选最小的 rrr，直接贪心往后选，如果相同就分段。 这样可能使得字母不够用，那么把字母比较大的都变成 zzz 即可。 1461E（#） 开始的时候k在[l,r]内。分类讨论。 如果x&gt;=y，一天过后水不会变多，第一天特殊考虑，剩下每一天一定会加水（尽量大，一定不会超过r）。 如果x&lt;y，那么就是一直倒水直到再倒要 &lt;l了，就加水。看上去这种复杂度很高，不过可以发现，再倒要&lt;l的状态只有x种，即l,l+1,…,l+x-1，如果出现环（即状态重复出现）那么就一定能无限进行下去，否则每个状态最多遍历一次，复杂度O(x)。 1477C（#） 如果构造的方案存在钝角∠ABC，那么根据大边对大角，AC一定严格比AB和BC长。 所以如果AB比AC长就不存在这个问题，每次取离A最远的B即可。 1201D 可以发现，最后一定是在一行了里面走，然后向上，再走，再向上。 可以发现一行里停的一定是当前行最左/最右的障碍，你没有必要取完最后一个障碍后还移动，这不如走上去后再移动。 把中间空余的行删去， 然后从下一行到上一行，一种是先往左后往右，一种是先往右后往左， 都计算一下即可。 方便起见在第一行加 (1,1)(1,1)(1,1) 当宝藏。 990E 枚举第 iii 种用来power。 那么你每次为了尽量不重复，一定会选择不超过 now+inow+inow+i 的尽量靠后的非障碍位置。 先判断最长的连续障碍段长度，否则你每个障碍最多回退一步，相当于每次不超过 (n+m)/i(n+m)/i(n+m)/i，可以通过。 1216F 设 dpidp_idpi​ 表示恰好覆盖了不超过 iii 的最小代价。 那么覆盖 iii 应该从 i−ki-ki−k，求 [i−2k−1,i−1][i-2k-1,i-1][i−2k−1,i−1] 的 dpdpdp 最小值转移过来即可（单调队列）。 注意需要 dpdpdp 到 n+kn+kn+k。 1385F 你找到深度最深的（叶子）节点，看它的父亲，如果为叶子的儿子个数 ≥k\\geq k≥k，就删。 如果没有 kkk 个，那么它的父亲就没救了，包括所有儿子无论如何都不行。 1166D（#） 你考虑前缀和，xi=Si−1+rix_i=S_{i-1}+r_ixi​=Si−1​+ri​，那么 Si=2Si−1+riS_i=2S_{i-1}+r_iSi​=2Si−1​+ri​。 那么你要 Sn−1+1&lt;=b&lt;=Sn−1+mS_{n-1}+1&lt;=b&lt;=S_{n-1}+mSn−1​+1&lt;=b&lt;=Sn−1​+m。 你先让 SSS 尽量小，然后再反过来加大，先给 Sn−1S_{n-1}Sn−1​ 加大同时满足条件，把剩下的给 Sn−2S_{n-2}Sn−2​，再不停的往前推。 1583E（#） 根据经典套路先求一棵生成树。询问给路径上的边都+1，这个和路径具体是什么有关系。 考虑设f[u]表示u相邻的边之和的奇偶性，这个和路径具体使什么没关系，一次操作给两端点都异或1。 如果最后存在f是奇数显然无解，否则叶子节点的那些边已经合法，那么推到他们父亲连到父亲的边也合法，一直推可以说明所有的边都合法，即只需要取一棵生成树，合法的依旧合法。 1335F（#） 如果两个机器人走到某一步在同一个格子，那么继续走下去还会在同一个格子。 它要求一直走下去，而走nm步后一定会进入环，所以只需要要求走nm步之后不在同一个格子即可。 现在要求走nm后到哪个位置，这个可以用倍增（也可以对于每个环倒着处理到这个环的点，不带log）。 能到达某个格子的多个位置，如果有黑色尽量选黑色，否则任意选。 1453E 观察一下它走的路径，容易发现进了一棵子树一定是走完了再出来，这个容易归纳证明。 你最后退出时走的那个子树，要增加一些从当前根出去的距离，所以一定是 dpdpdp 最小的子树，子树之间走的一定是最大的。而根节点需要特判，你可以只走次大的，最大的走完直接结束。 650C（#） 同行/同列值相同的位置最终值也会相同，先用并查集并起来形成一个等价类。 现在一行里等价类按照权值小向大连单向边，代表大小关系，可以发现只需要连大小顺序相邻的。 最后需要的步数至少是DAG最长链长度，可以构造每个点的权值为0度点到当前点的最长链的长度达到下界。 623B（#） 还是一样，考虑最后的素因子（每个数都是它的倍数）。 如果一个数不变,+1或-1都不是它的倍数，那么就必须在区间内。 如果有必须在区间内的数，求它们最小和最大的位置，它们之前的一个后缀，之后的一个前缀也可以在区间内，计算一下。否则任意一个数都能在区间内，一个前缀和一个后缀不在区间内，计算一下前缀后缀。 对于原问题，由于不能删完，所以第一个数或最后一个数一定保留，它必须是它们不变,+1,-1中某个的素因子，这样只有两位数种方案，分别判断即可。 1413E（#） 发现如果a&gt;bc，那么他无论怎么恢复都不如减的多，答案是无穷大。 否则a&lt;=bc，不妨假设0时刻你就攻击，到a/b上取整时刻，减的就比加的多了，不如第一个不做。 所以只需要考虑到[(a-1)/b]时刻，那么你一定是能攻击就攻击，在[[(a-1)/b]/d]次操作后达到最大值。 计算一下答案即可。 748D（#） 一定是中间一个回文串（或者没有），然后左边是若干个s，右边是若干个rev(s)。 对于代价和为正的非回文原串和反串一定选，代价和为正的回文原串和反串先选。 最后看看要不要拿掉选的回文串对中的较小值或加入未选回文串的最大值。 912D（#） 显然期望可以拆开，变成期望最大的k个位置的和。 对于(x,y)，能覆盖它的渔网数量=(min(x+r-1,m)-max(x,r)+1)*(min(y+r-1,m)-max(y,r)+1)。 那么两维相对独立，求出(min(x+r-1,m)-max(x,r)+1)的所有x的取值从大到小排，对于y同理。 然后可以使用堆贪心，因为u[1]*v[1]&gt;u[2]*v[1],u[1]*v[1]&gt;u[1]*v[2]，取出前k个即可。 486E（#） 判断一个数能不能在LIS上：求出以每个数为开头/结尾的LIS长度，看看加起来-1是否等于最长的LIS长度。如果等于，那么说明它在LIS上，且位置固定（它一定是LIS上第x个位置）。 判断一个数是不是必须在LIS上：看LIS第x个位置有没有多种选法，如果有就不必须在，否则必须在。 884D 倒过来变成合并，每次把两堆或三堆合并成一堆。 显然合并三堆是更优的（类似三叉哈夫曼树），但是可能合并不完，因为每次是3-&gt;1，减少两个，如果初始有偶数堆最后会剩两堆。 发现不如初始先合并最小的两堆，再做。 1292C 推式子，它这个是个排列， ∑1≤u&lt;v≤nmex⁡(u→v)=∑1≤u&lt;v≤n∑i≥1[mex⁡(u→v)≥i]=∑i≥1∑1≤u&lt;v≤n[mex⁡(u→v)≥i] \\begin{aligned} &amp;\\sum_{1\\leq u\\lt v\\leq n} \\operatorname{mex}(u \\rightarrow v)\\\\ =&amp;\\sum_{1\\leq u\\lt v\\leq n} \\sum_{i\\geq 1} [\\operatorname{mex}(u\\rightarrow v)\\geq i]\\\\ =&amp;\\sum_{i\\geq 1} \\sum_{1\\leq u\\lt v\\leq n} [\\operatorname{mex}(u\\rightarrow v)\\geq i] \\end{aligned} ==​1≤u&lt;v≤n∑​mex(u→v)1≤u&lt;v≤n∑​i≥1∑​[mex(u→v)≥i]i≥1∑​1≤u&lt;v≤n∑​[mex(u→v)≥i]​ 也就是有多少 (u,v)(u,v)(u,v)，使得路径上包含 0..i−10..i-10..i−1 的所有数。 那么首先 0..i−10..i-10..i−1 要在同一条路径上 iii 才可能计算答案。 其次如果固定 iii 满足条件（0..i−10..i-10..i−1 在同一条路径上），那么最理想的方案是两端有一个 i−1i-1i−1，这样到 i−1i-1i−1 可以删去一个数。所以一定是初始有一个 000，然后从小到大，往链两端加入一条权值为 iii 的边，贡献是两端子树大小乘积。 求出这个子树大小，然后倒过来递归，每次删去两端的一端，递归下去。 状态数 O(n2)\\mathcal{O}(n^2)O(n2)，转移 O(1)\\mathcal{O}(1)O(1)，记忆化搜索即可。 1251E1 直接来做 E2。 按照 mim_imi​ 从小到大排序，有个朴素的想法是设 dp[i][j]dp[i][j]dp[i][j] 表示考虑完前 iii 个，i+1..ni+1..ni+1..n 还有 jjj 个被贿赂的最小代价。 转移第一种是 i+1i+1i+1 被贿赂，就转移到 dp[i+1][j−1]+qi+1dp[i+1][j-1]+q_{i+1}dp[i+1][j−1]+qi+1​；第二种是没被贿赂，那么要求 i+j≥mi+1i+j\\geq m_{i+1}i+j≥mi+1​，转移到 dp[i+1][j]dp[i+1][j]dp[i+1][j]。这足以通过 E1。 发现 i+j≥mi+1i+j\\geq m_{i+1}i+j≥mi+1​ 可以移项成为 j≥mi+1−ij\\geq m_{i+1}-ij≥mi+1​−i，也就是一个人跟风为你投票当且仅当后面被贿赂的人数 ≥mi−i+1\\geq m_i-i+1≥mi​−i+1。 把 mim_imi​ 相同的放在一起，倒过来考虑，设当前 ≥mi\\geq m_i≥mi​ 被贿赂的人数为 cnt1cnt1cnt1，&lt;mi&lt;m_i&lt;mi​ 的人数为 cnt2cnt2cnt2，相当于现在一定有 cnt1+cnt2cnt1+cnt2cnt1+cnt2 个人投票，如果够了，那么能全部都选；否则不够，就需要在 ≥mi\\geq m_i≥mi​ 里的再贿赂一些，显然贿赂的越少越好（如果不够之后可以再贿赂），就贿赂直到 cnt1+cnt2cnt1+cnt2cnt1+cnt2 足够，拿个小根堆存一下。 723E（#） 显然度数是奇数的永远不可能合法。 如果只有度数为偶数的点，根据套路，可以考虑欧拉路，恰好有n次进入n次退出。 如果有部分度数为奇数的点，考虑把它们度数也变成偶数，即加一个新点连向所有度数为奇数的点。这样所有度数为偶数的点都合法。 1236D 它的起点在左上角，所以你一定是越绕越小的螺旋形。假如你直走也可以走，右转也可以走，此时你必须直走，因为如果你转弯了，你就再也绕不出来了。 暴力复杂度一定是对的，你每转2次两维必定都减少1。维护一下四个方向的边界，不能超出。最后为了防止不出现没走到的，判断一下走过的格子数量是否为非障碍格子数量。 你找下一个停下的位置，需要二分下一个障碍的左端和方向边界取较小值。 1028D 保证数字互不相同，ACCEPT给你提供了一些信息，即 &lt;x&lt;x&lt;x 的都在 AAA，&gt;x&gt;x&gt;x 的都在 BBB。 维护一定在 AAA 中数字的最大值 uuu 和一定在 BBB 中数字的最小值 vvv，和所有数的 setsetset。 如果ACCEPT的时候问的值比 uuu 小或比 vvv 大，就挂了，没有方案。否则如果这个数 &gt;u&gt;u&gt;u 且 &lt;v&lt;v&lt;v 那么不确定在哪个集合，方案数 ×2\\times 2×2。现在就能更新 u,vu,vu,v 了，uuu 是 &lt;x&lt;x&lt;x 的最大的数，vvv 是 &gt;x&gt;x&gt;x 的最小的数。 结束时还要乘上 u,vu,vu,v 之间的数字个数+1，可以选一个前缀给 AAA，剩下的给 BBB。 618D 从简单的入手讨论。 如果 y≤xy\\leq xy≤x，那肯定尽量走 yyy 边。你发现除了菊花图比较憨憨删去之后直接不连通了，其它情况一定可以都走 yyy。因为你考虑生成树是一个二分图，你如果两部有连边 (u,v)(u,v)(u,v)， 你可以在左边乱跳，然后停在 uuu，再到 vvv，最后在右边乱跳。 所以如果树不是菊花，那么答案是 (n−1)y(n-1)y(n−1)y，否则是 (n−2)y+x(n-2)y+x(n−2)y+x。 如果 x&gt;yx&gt;yx&gt;y，如果你选了 aaa 条 xxx 的路径，那么需要 aaa 条 yyy 把它们接起来。相当于要求树的最小（点）路径覆盖，树形dp即可。 242D（#） 这什么垃圾翻译。。。 和某题差不多，你每次找到一个cnt_i=a_i的，点一下，那么它以后再也不会不合法。 你最多把每个都点一次，所以一定有解。 804C（#） 先给1号点上的所有种类染色。考虑现在到点u，这个点上还有些种类没被染过色。 这些没被染过色的，可以给它们分配和u中染过色不同的，且两两不同的颜色。 尽量分配编号小的颜色，种类数应该是每个点上种类数max，可以发现没有比这样更少的方案。 980E 从大到小贪心，nnn 必须要选。 其它的从大到小贪心，能保留就保留。 保留即路径上的都得保留，判断一下路径上点的数量。 树状数组维护dfs序，删点就直接暴力，树状数组给子树-1。 732E 把电脑扔进multiset，把适配器排序贪心。 具体来说就是枚举除多少次，如果有就和multiset里的配对，删除。 1179C（#） 从大到小枚举最后剩下来的值x看看可不可行，可行当且仅当a_i&gt;=x的个数严格大于b_i&gt;=x的个数。 现在你要带修改，且要快速询问， 保存a_i&gt;=x的个数-b_i&gt;=x的个数，求最靠右的&gt;0的位置。 维护线段树，每次看右儿子的最大值，如果&lt;=0就到左儿子，否则到右儿子。 520D 维护一个大根堆一个小根堆，里面是能拆的方块。 拆了之后向四周扩展，把那些能拆的也加进去。取了的用 map 标记一下。 1616E 这题在现场。先求LCP，如果有前面大于后面就直接输出1. 否则你一定是两种情况之一：替换一个比它小的；替换一个和它一样的。 比它小的直接计算即可，维护后面每种字符的位置；一样的要移过来，维护个vector即可。 1498D（#） 相当于要维护这次操作过后哪些位置能到达。记f[i]为答案。 记g[i]表示这次操作选的a为多少才能到达i，对于之前能到达的i（之后可以一直a=0），g[i]=0。 然后更新，从小到大，g[i]+1-&gt;g[calc(i)]，最后将g[i]&lt;=y的且之前不能到达的i，f[i]更新为当前操作的编号。 622E 显然根的不同子树独立，分开考虑。 如果两个点深度不同，它们是不影响的。 两个深度相同的有交必定会完蛋，所以一定要一个等一秒，相当于深度+1。 所以现在就变成可以给若干个数增加，问全部互不相同时和最小为多少。 排序之后贪心即可。 1190C 先手如果一步就赢那么显然先手必胜。 不能一步就赢，那么后手可以重复先手的操作使局面不变，也可以正常操作，所以要么是平局要么是后手必胜。问题的关键就看后手能不能一步就赢。 枚举先手取的区间，如果左右都相同，那么就可以必胜；否则如果两边都不完全相同，后手一定不可以获胜。如果先手不能必胜且不存在后手不可以必胜，就后手必胜。 1552E（#） 记c=⌈n/(k−1)⌉。 考虑先取出第二次出现位置最小的c个区间，将[第一次,第二次]做为它们的区间。 考虑从剩下的取出第三次出现位置最小的c个区间，将[第二次,第三次]做为它们的区间。 以此类推共取k-1次。可以发现不同组的区间显然两两不交，故一个位置被覆盖的次数最多为c。 1132D 答案显然有可二分性。 你每次一定给最邻近关机的电脑充电，因为你要求所有电脑都不能关机。 用优先队列维护电脑的关机时间，每次给最小的加，如果取出来的时候已经小于当前时间了说明它已经关机了，这个mid不行。 1534E（#） 假设第i个位置在异或中出现了c_i次（c_i必须是奇数）。令sum=Σc_i，则k|sum，c_i&lt;=sum/k。 满足这个当然有解，可以考虑看成矩阵（一行有k个，一列有sum/k个）以列为优先填。 在sum固定的情况下一定是让max{c_i}尽量小，可以变成初始c_i都为1，每次给最小的c_i+=2，看是否满足条件。它说答案不超过500次，最多也就500*k次操作，可以通过。 1148E（#） 首先总和不变。可以把操作看成对于s_j-s_i&gt;=1（=1相当于交换顺序，无关紧要）的两个数，s_j--，s_i++。 对s_i++，s_j--，只要对值相同的取最后/最前的一个，相对顺序就不会改变，说明存在操作使相对顺序不变。 将s,t排序，设a_i=t_i-s_i。现在要把前面的某个-1，后面的某个+1。可以发现有解相当于要求前缀和&gt;0。 具体的构造方法类似于括号序，看栈底和当前数的大小关系即可。 909D 直接暴力复杂度是平方的。容易想到把同颜色当成一个同色段。 左右的同色段每次长度减少1，中间的同色段每次长度减少2（左右都没了）。 可以暴力，因为每个点只会消失一次，所以可以直接暴力给每个段长度 −1/−2-1/-2−1/−2，如果减没了直接暴力合并，复杂度为 O(n)O(n)O(n)。 576B（#） 首先树相同必须重心相同，一棵树最多有两个重心，说明必须存在一个&lt;=2的循环。 如果存在不动点即p_i=i，可以造一个以i为根的菊花。 否则存在对换p_a=b,p_b=a，考虑断开a,b的边，那么发现两部分排列后将会变成对方。 所以如果存在长度为奇数的循环则无解。否则将循环上奇数位置连a，偶数位置连b即可。 496E 由于 aj≤bja_j\\leq b_jaj​≤bj​，所以可以把条件改为 −aj≤−ci,bj≤di-a_j\\leq -c_i,b_j\\leq d_i−aj​≤−ci​,bj​≤di​。 把演奏家按照 (−ci,di)(-c_i,d_i)(−ci​,di​) 的二元组排序，按照顺序，你一定是取 −aj≤−ci,bj≤di-a_j\\leq -c_i,b_j\\leq d_i−aj​≤−ci​,bj​≤di​ 中 bjb_jbj​ 最大的，因为之后的 −ci-c_i−ci​ 都不比当前的小，所以你只需要尽量的取 bib_ibi​ 大的。 229D 题目相当于分成若干个段，使得每段和不降，问n-最小段数。 设 fif_ifi​ 为 1..i1..i1..i 不降的最少段数，hih_ihi​ 为此时最后一个塔的最小高度。 有一个直观的想法：存在一种答案最小的方案，最后一个数也是最小的。 这个怎么证明呢，假设 1..i−11..i-11..i−1 都满足，那么 hhh 存的就是可能的最小高度。fif_ifi​ 的转移即为 fi=min⁡j&lt;i,hj≤sum(j+1,i){fj−j}+i−1f_i=\\min_{j&lt;i,h_j\\leq sum(j+1,i)} \\{f_j-j\\}+i-1 fi​=j&lt;i,hj​≤sum(j+1,i)min​{fj​−j}+i−1 这个形式不好看，设 gig_igi​ 为 fi−if_i-ifi​−i。 gi=min⁡j&lt;i,hj≤sum(j+1,i){gj}−1g_i=\\min_{j&lt;i,h_j\\leq sum(j+1,i)} \\{g_j\\}-1 gi​=j&lt;i,hj​≤sum(j+1,i)min​{gj​}−1 由于 gi−1g_{i-1}gi−1​ 可以转移的 jjj 在 gig_igi​ 也可以转移，所以 gi−1≥gig_{i-1}\\geq g_igi−1​≥gi​。所以你找到最大的满足条件的 jjj，它的 ggg 一定是最小的，同时 hhh 也是 sum(j+1,i)sum(j+1,i)sum(j+1,i)，即证明了 iii 也满足条件。 问题变成怎么找这个 jjj，j&lt;i,hj+prej≤preij&lt;i,h_j+pre_j\\leq pre_ij&lt;i,hj​+prej​≤prei​，而这个 preipre_iprei​ 也是单调递增的，故可以维护一个单调（hj+prejh_j+pre_jhj​+prej​ 递增）队列。 269C（#） 非源非汇的点流量平衡。 由于最后是DAG，考虑一个类似于拓扑排序的做法。 首先入度为0的应该是1号点和无边相连的点。 那么加入队列的，没访问的邻边都是出边，更新一下，看看另一端能不能加入队列。 1603C 如果你知道一个数最后分成了x个，那么一定是尽量平均的分配（设y=val mod x，则有x-y个u和y个u+1，其中u=[val/x]，无论怎么调整都不能使最大值减小或最小值增大）。 考虑怎么求整个序列的值，这就显而易见了，你从右往左，每次求最少操作几次，使得值不超过右边的数的值即可。 但是，你一个数拆分是整除的形式，即这个u只有sqrt V种，当前数尽量大，转移一下即可。 995C（#） 原来每个不超过1e6，最后要求和不超过1.5e6。 向量相加显然和夹角有关系，考虑哪些夹角可以。 c2=a2+b2−2abcos⁡Cc^2=a^2+b^2-2ab\\cos Cc2=a2+b2−2abcosC，不妨设 a≤ba\\leq ba≤b，那么 c2≤a2(1−2cos⁡C)+b2c^2\\leq a^2(1-2\\cos C)+b^2c2≤a2(1−2cosC)+b2，当 cosC≤1/2cosC\\leq 1/2cosC≤1/2 时 c2≤b2c^2\\leq b^2c2≤b2。 （这个是把两个向量首尾相接，形成三角形两条边）。 拿出三个向量，正反有6个向量，一定有两个夹角 ≤pi/3\\leq pi/3≤pi/3，满足条件。 到最后只剩下两个向量时，夹角之间 ≤pi/2\\leq pi/2≤pi/2，这样长度可能乘上 2\\sqrt 22​，也不超过1.5e6。 1217E（#） 有个简单的思路，平衡的是不是每一位最多只有一个数非0。 思考一下，发现如果有多个数某位都非0，且还要满足条件，那么一定需要进位。 对于前面的位，如果后面有进位，要满足条件自己也要进位。 到最后会进到一个没有数出现过的位，就gg了。 那么不平衡的一定有两个数在某一位都非0，要求最小就是这一位非0的最小的两个数之和。 线段树记录一下区间每一位非0的数中，最小和次小的值即可。 1158C（#） 先考虑没有-1的情况，存在i,j，i&lt;j&lt;nxt_i&lt;nxt_j一定无解。否则可以构造出解。 对于后缀最大值（nxt_i=n+1），它们之间的小区间又是独立的（nxt_j&lt;=i），递归下去做。 具体实现可以类似于建树，i的父亲是nxt_i，层数低的比层数高的值大，同层编号小的比编号大的值大。 nxt_i=-1的情况，直接取nxt_i=i+1即可，这样不会使得原来有解的变成无解。 808E 这题比较特殊的在于 wiw_iwi​ 不超过3。 只有两种比较经典，先从大到小排序，一定是要么+1，要么-1 +2。 枚举3有多少个，询问1,2组成的答案即可。 1468H（#） 首先每次减小 k−1k-1k−1 个，(n−m)mod(k−1)(n-m) mod (k-1)(n−m)mod(k−1) 不为 000 显然无解。 设 d=(k−1)/2d=(k-1)/2d=(k−1)/2，考虑最后一步，中心是 bxb_xbx​，删去了中心左边的 ddd 个数，右边的 ddd 个数。 如果不存在 xxx 使得 bxb_xbx​ 左/右边有 ddd 个非 bbb 中的数，那么显然无解。 否则你在前面删的时候，kkk 个数都取要删的数，一定能调整成最后 bxb_xbx​ 左右各 ddd 个数。 549B（#） 设b_i表示当前i收到的消息数量，初始b_i=0。如果不存在a_i=0那么直接结束。 每一次找到a_i=b_i，钦定i加入party，称这个操作为fix。 那么显然每个点fix过后b_i&gt;a_i，不会再次被fix。如果某一步找不到就结束。 508E 可以发现，只要在当前时间放右括号合法（和栈底）匹配，那么一定就直接匹配。 因为如果你中间再加点别的，不如在这个右括号后面加，并不影响其他的，只是可能导致当前栈底时间过了。 如果时间没到就加左括号拖时间，然后就可以大力模拟了！ 1411E（#） 这种题目（什么能不能达到，能不能凑出来）考虑寻找不变量（输入什么都不会变，或者只和极少输入的数有关）。寻找不变量之后考虑所有能到达的状态。 对于这题，就考虑字符是什么和字符前面的符号无关，考虑哪些符号是可达的。 首先最后一个一定是+号，同样的，倒数第二个一定是-号。 考虑是否满足这个条件就可以了，找到一对+-，那么就可以从减号的位置递归。 这有一种情况可能找不到，就是------…-+，只有最后一个位置是加号，那么取m=|S|-1即可。 去除最后两个数的限制，之前的可以直接贪心，从大到小排序，一个一个加入。否则你后面取的一定有一部分是抵消它的（这个是2的幂次，一次只能在一位上加），可以全部取反。 748E 记录瓣数为 iii 的橘子有多少个。 从大到小枚举答案，那么 ≥2i−1\\geq 2i-1≥2i−1 的都可以直接分了。如果当前 ≥i\\geq i≥i 的橘子数量 ≥k\\geq k≥k，那么直接OK，否则继续往下。 346C（#） 首先相同的x_i显然可以删去。2操作相当于走到左边一个最近的x_i的倍数。 如果2操作某个x_i已经&lt;b，那么之后操作这个x_i一定也&lt;b，删去即可。 否则就需要决策怎么走是最优的，发现一定是走2操作后最小的x_i，走到a-a mod x_i，否则假设走另一个x_j更优，那么考虑某一步一定会从&gt;=a-a mod x_i走到&lt;a-a mod x_i，那么这一步在a-a mod x_i开始也一定可以走，步数也不会更多。所以一定走2操作最小的。 算一下时间复杂度，你每两步操作就会使答案至少减少当前x的最大值，而x的最大值&gt;=数字的个数，而你每次操作的复杂度也是数字的个数，所以复杂度和a-b是线性关系。 979D（#） 把条件转化为v&lt;=s-x,k|v,k|x，要求x xor v最大。（可以直接判断k|x是否满足，不满足则无解） 由于v&lt;=10^5，如果你知道了所有k的倍数建的trie树，复杂度为O(log v)。 所以可以考虑在加入的时候，给所有k|v的trie插入v。 询问时只需要对k的trie查找，trie每个节点记录子树满足条件的最小的v是多少（要满足v&lt;=s-x），看往哪个子树走。 1601C 很容易想到，bbb 应该是按照递增的顺序插入aaa 的。 证明很简单，如果有相邻两个 bbb 中的数按 x&gt;yx&gt;yx&gt;y 插入，换成 y,xy,xy,x 一定不劣。 再想，是不是 x&lt;yx&lt;yx&lt;y，xxx 在 aaa 中第一个最优的位置 &lt;= yyy 在 aaa 中第一个最优的位置。 这个其实也好证明，设 ppp 为 xxx 插入到第1个位置前的逆序对数，vi=−1/0/1v_i=-1/0/1vi​=−1/0/1（分别对应 aia_iai​ 比 xxx 小，相等，比 xxx 大），那么 xxx 插入到第 iii 个位置后有 p+v1+v2+⋯+vip+v_1+v_2+\\cdots+v_ip+v1​+v2​+⋯+vi​ 个逆序对，所以第一个最优的位置为 vvv 的前缀和最小值第一次出现的位置。 那么当 xxx 增大时，有些 viv_ivi​ 减少了 111，对应到前缀和上是某些后缀减少了 111，最小值不可能前移。 一种可以用线段树维护最小值和出现位置，还有一种是用分治，求出 midmidmid 的第一个最优位置，那么左边和右边就完全没有关系了（它们之间的逆序对数是固定的），递归做即可。 552E（#） 如果把括号加在两个之间，对答案没有影响。如果加在一个 +++ 一个 ×\\times× 之间，那么在 +++ 那段扩展，答案一定也不会变劣。 所以只有可能在两个 ×\\times× 之间或一个端点一个 ×\\times× 之间加，枚举一下，然后暴力计算表达式即可。 550E（#） 特判n=1。如果最后一个数是1，那么无论怎么操作，最后一个数的值一定是1，无解。 如果倒数第二个是1，那么前面怎么合并都是1，最后和0合并即可。 000可以变成10，即只要最后0的个数=1或&gt;=3都一定有解。 考虑最后0的个数为2，即xxx…1..100。如果之前还有0，那么可以把1..10合并成0，那么最后就有3个0，有解；否则只能是1..100，不能操作00（最后一个数会变成1），操作11或10都是减少1个1，最后只能变成00，00显然没有合法方案。 1098B（#） 一种是隔行相同，隔列字符集合相同；一种是隔列相同，隔行字符集合相同。（或两者都有） 枚举一下是第一种还是第二种（2），枚举隔行/列相同的集合和顺序（4*3），枚举另一种的顺序（2），枚举另一种隔列/行变不变（2），然后算一下即可。 ","link":"https://hydd-new.github.io/greedy/"},{"title":"NOIP2021 方差","content":"考场30min完成前面两题，就一直想调整，打表，花了好几个小时。 我当时也在想，估计要找能到达的集合有什么规律，但就是找不到。 在调整和打表找规律反复横跳，然后就自闭了。 na‾=∑i=1nain2D=n∑i=1n(ai−a‾)2=n∑i=1nai2−2na‾∑i=1nai+n2a‾2=n∑i=1nai2−2(∑i=1nai)2+(∑i=1nai)2=n∑i=1nai2−(∑i=1nai)2\\begin{aligned} n\\overline{a}&amp;=\\sum_{i=1}^na_i\\\\ \\\\ n^2D &amp;=n\\sum_{i=1}^n(a_i-\\overline{a})^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-2n\\overline{a}\\sum_{i=1}^n a_i+n^2\\overline{a}^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-2(\\sum_{i=1}^n a_i)^2+(\\sum_{i=1}^n a_i)^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-(\\sum_{i=1}^n a_i)^2\\\\ \\end{aligned} nan2D​=i=1∑n​ai​=ni=1∑n​(ai​−a)2=ni=1∑n​ai2​−2nai=1∑n​ai​+n2a2=ni=1∑n​ai2​−2(i=1∑n​ai​)2+(i=1∑n​ai​)2=ni=1∑n​ai2​−(i=1∑n​ai​)2​ 观察题目中的式子，ai′←ai−1+ai+1−aia&#x27;_i\\leftarrow a_{i-1}+a_{i+1}-a_iai′​←ai−1​+ai+1​−ai​，根据 CF1110E 的套路，可以差分，令 di=ai+1−ai(1≤i&lt;n)d_i=a_{i+1}-a_i(1\\leq i\\lt n)di​=ai+1​−ai​(1≤i&lt;n)，一次操作 (2≤i&lt;n)(2\\leq i\\lt n)(2≤i&lt;n) 即： di−1′=ai′−ai−1′=(ai−1+ai+1−ai)−ai−1=ai+1−ai=didi′=ai+1′−ai′=ai+1−(ai−1+ai+1−ai)=ai−ai−1=di−1d&#x27;_{i-1}=a&#x27;_{i}-a&#x27;_{i-1}=(a_{i-1}+a_{i+1}-a_i)-a_{i-1}=a_{i+1}-a_i=d_i\\\\ d&#x27;_i=a&#x27;_{i+1}-a&#x27;_{i}=a_{i+1}-(a_{i-1}+a_{i+1}-a_i)=a_i-a_{i-1}=d_{i-1} di−1′​=ai′​−ai−1′​=(ai−1​+ai+1​−ai​)−ai−1​=ai+1​−ai​=di​di′​=ai+1′​−ai′​=ai+1​−(ai−1​+ai+1​−ai​)=ai​−ai−1​=di−1​ 相当于交换 di−1,di(2≤i&lt;n)d_{i-1},d_i(2\\leq i\\lt n)di−1​,di​(2≤i&lt;n)，故 ddd 可以通过若干次操作，变为任意 ddd 的排列。 由于 a1a_1a1​ 不变，那么 aaa 和 ddd 是一一对应的。现在要求一个 ddd 的排列使得 n2Dn^2Dn2D 最小，继续推式子： n2D=n∑i=1nai2−(∑i=1nai)2=n∑i=1nai2−∑i=1n∑j=1naiaj=12(n∑i=1nai2−2∑i=1n∑j=1naiaj+n∑j=1naj2)=12(∑i=1n∑j=1n(ai−aj)2)=∑i=1n−1∑j=in−1(aj+1−ai)2=∑i=1n−1∑j=in−1(di+di+1+⋯+dj)2\\begin{aligned} n^2D &amp;=n\\sum_{i=1}^n a_i^2-(\\sum_{i=1}^n a_i)^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-\\sum_{i=1}^n\\sum_{j=1}^na_ia_j\\\\ &amp;=\\frac{1}{2}(n\\sum_{i=1}^n a_i^2-2\\sum_{i=1}^n\\sum_{j=1}^na_ia_j+n\\sum_{j=1}^n a_j^2)\\\\ &amp;=\\frac{1}{2}(\\sum_{i=1}^n\\sum_{j=1}^n(a_i-a_j)^2)\\\\ &amp;=\\sum_{i=1}^{n-1}\\sum_{j=i}^{n-1}(a_{j+1}-a_i)^2\\\\ &amp;=\\sum_{i=1}^{n-1}\\sum_{j=i}^{n-1}(d_i+d_{i+1}+\\cdots+d_j)^2\\\\ \\end{aligned} n2D​=ni=1∑n​ai2​−(i=1∑n​ai​)2=ni=1∑n​ai2​−i=1∑n​j=1∑n​ai​aj​=21​(ni=1∑n​ai2​−2i=1∑n​j=1∑n​ai​aj​+nj=1∑n​aj2​)=21​(i=1∑n​j=1∑n​(ai​−aj​)2)=i=1∑n−1​j=i∑n−1​(aj+1​−ai​)2=i=1∑n−1​j=i∑n−1​(di​+di+1​+⋯+dj​)2​ n2Dn^2Dn2D 取最小值时，ddd 一定是先递减后递增的。 考虑在分界位置（即递减到递增）从小到大往两边加数，由于 n2D=n∑i=1nai2−(∑i=1nai)2\\begin{aligned} n^2D &amp;=n\\sum_{i=1}^n a_i^2-(\\sum_{i=1}^n a_i)^2\\\\ \\end{aligned} n2D​=ni=1∑n​ai2​−(i=1∑n​ai​)2​ 维护 dp[k][s]dp[k][s]dp[k][s] 表示当前已经加入了 kkk 个数，现在的 aaa 之和为 sss 的最小 ∑i=1nai2\\displaystyle \\sum_{i=1}^n a_i^2i=1∑n​ai2​。 初始 dp[1][s]=0dp[1][s]=0dp[1][s]=0。 转移时考虑加到左边还是右边： 左边：原来是 a1,a2,⋯ ,aka_1,a_2,\\cdots,a_ka1​,a2​,⋯,ak​，现在变为 d,a1+d,a2+d,⋯ ,ak+dd,a_1+d,a_2+d,\\cdots,a_k+dd,a1​+d,a2​+d,⋯,ak​+d，新增的贡献为 Δ=d2+∑i=1k(d+ai)2−∑i=1kai2=(k+1)d2+2d∑i=1kai=(k+1)d2+2ds\\begin{aligned} \\Delta &amp;=d^2+\\sum_{i=1}^k (d+a_i)^2-\\sum_{i=1}^k a_i^2\\\\ &amp;=(k+1)d^2+2d\\sum_{i=1}^ka_i\\\\ &amp;=(k+1)d^2+2ds\\\\ \\end{aligned} Δ​=d2+i=1∑k​(d+ai​)2−i=1∑k​ai2​=(k+1)d2+2di=1∑k​ai​=(k+1)d2+2ds​ 右边：原来是 a1,a2,⋯ ,aka_1,a_2,\\cdots,a_ka1​,a2​,⋯,ak​，现在变为 a1,a2,⋯ ,ak,ak+da_1,a_2,\\cdots,a_k,a_k+da1​,a2​,⋯,ak​,ak​+d，新增的贡献为Δ=(ak+d)2\\begin{aligned} \\Delta &amp;=(a_k+d)^2\\\\ \\end{aligned} Δ​=(ak​+d)2​ 其实可以发现 aka_kak​ 是固定的，为之前所有的 ddd 之和，不需要再记录。 答案为 min⁡s{n×dp[n][s]−s2}\\displaystyle \\min_s\\{n\\times dp[n][s]-s^2\\}smin​{n×dp[n][s]−s2}。 分析一下时间复杂度，第一维是 O(n)O(n)O(n) 的，第二维是 O(nV)O(nV)O(nV) 的，转移 O(1)O(1)O(1)。 但是可以发现 ddd 为 000 的转移可以忽略，第一维是 O(min⁡(n,V))O(\\min(n,V))O(min(n,V)) 的，总复杂度为 O(nV2)O(nV^2)O(nV2)，可以通过。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=1ll&lt;&lt;60; int n,a[11000],d[11000]; ll dp[510000]; ll sqr(ll x){ return x*x;} int main(){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for (int i=1;i&lt;n;i++) d[i]=a[i+1]-a[i]; sort(d+1,d+n); for (int i=0;i&lt;=500000;i++) dp[i]=INF; dp[0]=0; int lim=0,sum=0; for (int i=1;i&lt;n;i++){ if (!d[i]) continue; for (int s=lim;s&gt;=0;s--){ if (dp[s]==INF) continue; dp[s+sum+d[i]]=min(dp[s+sum+d[i]],dp[s]+sqr(sum+d[i])); dp[s+i*d[i]]=min(dp[s+i*d[i]],dp[s]+2*s*d[i]+i*sqr(d[i])); dp[s]=INF; } lim+=i*d[i]; sum+=d[i]; } ll ans=INF; for (int i=0;i&lt;=lim;i++) if (dp[i]!=INF) ans=min(ans,n*dp[i]-1ll*i*i); printf(&quot;%lld\\n&quot;,ans); return 0; } ","link":"https://hydd-new.github.io/NOIP21T3/"},{"title":"CF1603E","content":" 如果 max(a1,a2,⋯ ,am)⋅min(a1,a2,⋯ ,am)≥a1+a2+⋯+ammax(a_1,a_2,\\cdots,a_m)\\cdot min(a_1,a_2,\\cdots,a_m)\\geq a_1+a_2+\\cdots+a_mmax(a1​,a2​,⋯,am​)⋅min(a1​,a2​,⋯,am​)≥a1​+a2​+⋯+am​，则整数序列 a1,a2,⋯ ,ama_1,a_2,\\cdots,a_ma1​,a2​,⋯,am​ 被称为好的。 如果 aaa 的每个非空子序列都是好的，则整数序列 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 被称为完美的。 给定两个整数 nnn 和 MMM，MMM 是素数。求完美序列 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 且每项满足 1≤ai≤n+11\\leq a_i\\leq n+11≤ai​≤n+1 的数量，对 MMM 取模。 1≤n≤200,108≤M≤1091\\leq n\\leq 200,10^8\\leq M\\leq 10^91≤n≤200,108≤M≤109。 sol 可以发现 一个序列是完美的 等价于 将它从小到大排序后的序列是完美的（即顺序无关）。 判断一个从小到大的序列是否是完美的 以下的序列，aaa 都是从小到大的序列。 发现这等价于这个序列的所有前缀都是好的。 假设选出的子序列的最小/最大下标分别为 l,rl,rl,r，那么 mul≥a1⋅ar≥a1+a2+⋯ar≥summul\\geq a_1\\cdot a_r\\geq a_1+a_2+\\cdots a_r\\geq summul≥a1​⋅ar​≥a1​+a2​+⋯ar​≥sum。 这还不够，我们再找一些条件。 ak≥ka_k\\geq kak​≥k。 如果不满足，则 a1⋅ak&lt;a1⋯k&lt;a1+a2+⋯ara_1\\cdot a_k&lt;a_1\\cdots k&lt;a_1+a_2+\\cdots a_ra1​⋅ak​&lt;a1​⋯k&lt;a1​+a2​+⋯ar​ 矛盾。 若存在 ak=ka_k=kak​=k，则 a1=a2=⋯=ak=ka_1=a_2=\\cdots=a_k=ka1​=a2​=⋯=ak​=k。 a1⋅ak=a1⋅k≥a1+a2+⋯ara_1\\cdot a_k=a_1\\cdot k\\geq a_1+a_2+\\cdots a_ra1​⋅ak​=a1​⋅k≥a1​+a2​+⋯ar​，即 (a1−a1)+(a2−a1)+⋯+(ak−a1)≤0(a_1-a_1)+(a_2-a_1)+\\cdots+(a_k-a_1)\\leq 0(a1​−a1​)+(a2​−a1​)+⋯+(ak​−a1​)≤0，而 ai≥a1a_i\\geq a_1ai​≥a1​，所以 ai=ka_i=kai​=k。 可以发现 an=na_n=nan​=n 只有一种方案，否则 an=n+1a_n=n+1an​=n+1。 如果 an=n+1,ai≥i+1a_n=n+1,a_i\\geq i+1an​=n+1,ai​≥i+1，那么整个序列是完美的 等价于 整个序列是好的。 整个序列是好的当且仅当 (a1−a1)+(a2−a1)+⋯+(an−a1)≤a1(a_1-a_1)+(a_2-a_1)+\\cdots+(a_n-a_1)\\leq a_1(a1​−a1​)+(a2​−a1​)+⋯+(an​−a1​)≤a1​。 整个序列是完美的显然必须满足整个序列是好的。 考虑前缀 1..k1..k1..k，它是好的当且仅当 (a1−a1)+(a2−a1)+⋯+(ak−a1)≤a1⋅(ak−k)(a_1-a_1)+(a_2-a_1)+\\cdots+(a_k-a_1)\\leq a_1\\cdot (a_k-k)(a1​−a1​)+(a2​−a1​)+⋯+(ak​−a1​)≤a1​⋅(ak​−k)，若满足 (a1−a1)+(a2−a1)+⋯+(an−a1)≤a1(a_1-a_1)+(a_2-a_1)+\\cdots+(a_n-a_1)\\leq a_1(a1​−a1​)+(a2​−a1​)+⋯+(an​−a1​)≤a1​（整个序列是好的） 则一定满足上述条件，而每个前缀都是好的所以整个序列是完美的。 如果 an=n+1,ai≥ia_n=n+1,a_i\\geq ian​=n+1,ai​≥i，那么整个序列是完美的 等价于 满足条件 2，且整个序列是好的。 满足条件 2，假设 a1=a2=⋯=ak=ka_1=a_2=\\cdots=a_k=ka1​=a2​=⋯=ak​=k，对于长度不超过 kkk 的前缀显然都是好的。 长度超过 kkk 的前缀证明和 3 类似。 从小到大的完美序列的方案数 固定 a1a_1a1​ 的值： a1≤a2≤⋯≤ana_1\\leq a_2\\leq \\cdots \\leq a_na1​≤a2​≤⋯≤an​。 对于 i≤a1i\\leq a_1i≤a1​，a1≤ai≤n+1a_1\\leq a_i\\leq n+1a1​≤ai​≤n+1 a2⋯ai−1a_2\\cdots a_{i-1}a2​⋯ai−1​ 不能 &lt;a1&lt;a_1&lt;a1​，否则就和单调性（从小到大）矛盾。 aa1a_{a_1}aa1​​ 可以是 aa1a_{a_1}aa1​​ 也可以是更大的数。 你也可以把这个条件当成：对于 i&lt;a1i\\lt a_1i&lt;a1​，i+1≤ai≤n+1i+1\\leq a_i\\leq n+1i+1≤ai​≤n+1 且 a1≤aa1≤n+1a_1\\leq a_{a_1}\\leq n+1a1​≤aa1​​≤n+1，但是这个形式不便于之后的计算。 对于 i&gt;a1i&gt;a_1i&gt;a1​，i+1≤ai≤n+1i+1\\leq a_i\\leq n+1i+1≤ai​≤n+1 aia_iai​ 不能取 iii，否则就和 a1a_1a1​ 的值矛盾（条件2）。 (a1−a1)+(a2−a1)+⋯+(an−a1)≤a1(a_1-a_1)+(a_2-a_1)+\\cdots+(a_n-a_1)\\leq a_1(a1​−a1​)+(a2​−a1​)+⋯+(an​−a1​)≤a1​。 设 bi=ai−a1b_i=a_i-a_1bi​=ai​−a1​，那么： b1=0b_1=0b1​=0 b1≤b2≤⋯≤bnb_1\\leq b_2\\leq \\cdots \\leq b_nb1​≤b2​≤⋯≤bn​ 0≤bi≤n+1−a10\\leq b_i\\leq n+1-a_10≤bi​≤n+1−a1​ b1+b2+⋯+bn≤a1b_1+b_2+\\cdots+b_n\\leq a_1b1​+b2​+⋯+bn​≤a1​ bn≥n+1−a1b_n\\geq n+1-a_1bn​≥n+1−a1​，bn−1≥n−a1b_{n-1}\\geq n-a_1bn−1​≥n−a1​，...，ba1+1≥2b_{a_1+1}\\geq 2ba1​+1​≥2 显然固定 a1a_1a1​ 后，bbb 和 aaa 是一一对应的。 由于需要满足 bn≥n+1−a1b_n\\geq n+1-a_1bn​≥n+1−a1​，bn−1≥n−a1b_{n-1}\\geq n-a_1bn−1​≥n−a1​，...，ba1+1≥2b_{a_1+1}\\geq 2ba1​+1​≥2 和 b1+b2+⋯+bn≤a1b_1+b_2+\\cdots+b_n\\leq a_1b1​+b2​+⋯+bn​≤a1​ 这两个条件，a1a_1a1​ 大概只有 O(n)O(\\sqrt n)O(n​) 种取值。 枚举发现 nnn 取最大值 200200200 时，a1≥n−17a_1\\geq n-17a1​≥n−17。 完美序列的方案数 即上面的做法的 bbb 顺序可以任意排列。 依旧固定 aaa 的最小值 x(x≥n−17)x(x\\geq n-17)x(x≥n−17)： 设 bi=ai−xb_i=a_i-xbi​=ai​−x，那么： ∃k,bk=0\\exists k,b_k=0∃k,bk​=0 0≤bi≤n+1−x0\\leq b_i\\leq n+1-x0≤bi​≤n+1−x b1+b2+⋯+bn≤xb_1+b_2+\\cdots+b_n\\leq xb1​+b2​+⋯+bn​≤x ≥1\\geq 1≥1 个数 ≥n+1−x\\geq n+1-x≥n+1−x，≥2\\geq 2≥2 个数 ≥n−x\\geq n-x≥n−x，...，≥n−x\\geq n-x≥n−x 个数 ≥2\\geq 2≥2。 这等价于 ≤x\\leq x≤x 个数 ≤1\\leq 1≤1，≤x+1\\leq x+1≤x+1 个数 ≤2\\leq 2≤2，...，≤n−1\\leq n-1≤n−1 个数 ≤n−x\\leq n-x≤n−x（再加个 ≤n\\leq n≤n 个数 ≤n+1−x\\leq n+1-x≤n+1−x 也不影响）。 对 bbb 计数，设 dp[i][j][k]dp[i][j][k]dp[i][j][k] 表示考虑完值 ≤i\\leq i≤i 的位置，共选了 j(j≤x+i−1)j(j\\leq x+i-1)j(j≤x+i−1) 个数，选的数之和为 kkk 的方案数。转移枚举有 ttt 个值为 iii 的位置，从 dp[i−1][j−t][k−i∗t]t!\\frac{dp[i-1][j-t][k-i*t]}{t!}t!dp[i−1][j−t][k−i∗t]​ 转移过来。除这个阶乘是因为组合数选位置，最后计算答案要乘上 n!n!n!。 实现时可以使用记忆化，实际用到的状态并不多。理论时间复杂度为 O(n3nlog⁡n)O(n^3\\sqrt n\\log n)O(n3n​logn)。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int n,Mod,x; ll fac[210],inv[210]; int dp[210][210][210]; int solve(int i,int j,int k){ if (!i) return (k?0:(!j?0:inv[j])); if (j&gt;x+i-1) return 0; if (~dp[i][j][k]) return dp[i][j][k]; int res=0; for (int t=0;t&lt;=j&amp;&amp;i*t&lt;=k;t++) res=(res+solve(i-1,j-t,k-i*t)*inv[t])%Mod; dp[i][j][k]=res; return res; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;Mod); fac[0]=1; for (int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=n;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=n;i++) inv[i]=inv[i-1]*inv[i]%Mod; int ans=0; for (x=max(1,n-17);x&lt;=n+1;x++){ memset(dp,-1,sizeof(dp)); for (int k=0;k&lt;=x;k++) ans=(ans+solve(n+1-x,n,k))%Mod; } printf(&quot;%lld\\n&quot;,ans*fac[n]%Mod); return 0; } ","link":"https://hydd-new.github.io/CF1603E/"},{"title":"min_25筛","content":"是什么 Min_25 筛是一种求积性函数前缀和的算法。 具体来说，对于一个积性函数 fff，求： ans=∑i=1nf(i)ans=\\sum_{i=1}^n f(i) ans=i=1∑n​f(i) 需要快速计算素数的幂的值。计算素数个数函数 π(n)\\pi(n)π(n) 的时间复杂度为 O(n34log⁡n)O(\\dfrac{n^{\\frac{3}{4}}}{\\log n})O(lognn43​​)（它只用到第一步），计算其它函数时间复杂度为 O(n1−ϵ)O(n^{1-\\epsilon})O(n1−ϵ)（一般能跑过的范围内，也可以按照 O(n34log⁡n)O(\\dfrac{n^{\\frac{3}{4}}}{\\log n})O(lognn43​​) 计算）。 怎么做 第一步 思考下面这个问题： G(n)=∑i=1n[i∈P]f(i)G(n)=\\sum_{i=1}^n [i\\in \\mathbb P]f(i) G(n)=i=1∑n​[i∈P]f(i) 其中 P\\mathbb PP 是素数集。 考虑我们是怎么筛素数的，有一种方法是埃氏筛，就是枚举 ppp，然后将最小素因子是 ppp 的合数筛去。 当然，我们不能直接像埃氏筛一样枚举最小素因子是 ppp 的合数，这样还不如直接暴力。 先找到完全积性函数 f′f&#x27;f′ 满足对于任意 x∈Px\\in \\mathbb Px∈P，f′(x)=f(x)f&#x27;(x)=f(x)f′(x)=f(x)，显然满足条件的 f′f&#x27;f′ 只有一个（完全积性函数由素数位置的点值唯一确定）。 设 g(n,j)g(n,j)g(n,j) 表示 2,3,⋯ ,n2,3,\\cdots,n2,3,⋯,n 这些数经过 jjj 轮埃氏筛（即筛了前 jjj 个素数）后，剩下的 f′f&#x27;f′ 的值和，111 没有贡献，则 G(n)=g(n,∣P∣)G(n)=g(n,|P|)G(n)=g(n,∣P∣)。 即 iii 是质数或者 iii 的最小素因子大于 PjP_jPj​ 的 f′(i)f&#x27;(i)f′(i) 之和，具体地： g(n,j)=∑i=2n[i∈P or⁡ minp⁡(i)&gt;Pj]f′(i)g(n,j)=\\sum_{i=2}^n [i\\in \\mathbb P\\space \\operatorname{or}\\space \\operatorname{minp}(i)\\gt P_j]f&#x27;(i) g(n,j)=i=2∑n​[i∈P or minp(i)&gt;Pj​]f′(i) 其中 minp⁡(i)\\operatorname{minp}(i)minp(i) 表示 iii 的最小素因子，PjP_jPj​ 表示第 jjj 小的素数。 考虑使用 dpdpdp 来计算 g(n,j)g(n,j)g(n,j)，那么要在 g(n,j−1)g(n,j-1)g(n,j−1) 中剩下的数中把最小素因子是 PjP_jPj​ 的合数筛去。 Pj2P_j^2Pj2​ 为满足最小素因子是 PjP_jPj​ 的最小合数，分情况讨论： Pj2&gt;nP_j^2\\gt nPj2​&gt;n，不存在最小素因子是 PjP_jPj​ 的合数，g(n,j)=g(n,j−1)g(n,j)=g(n,j-1)g(n,j)=g(n,j−1)； Pj2≤nP_j^2\\leq nPj2​≤n，f′f&#x27;f′ 满足完全积性，且会被筛掉的数为 2,3,⋯ ,⌊nPj⌋2,3,\\cdots,\\lfloor\\dfrac{n}{P_j}\\rfloor2,3,⋯,⌊Pj​n​⌋ 中任何满足 minp⁡(x)&gt;Pj−1\\operatorname{minp}(x)&gt;P_{j-1}minp(x)&gt;Pj−1​ 的数 x×Pjx\\times P_jx×Pj​，g(n,j)=g(n,j−1)−f′(Pj)[g(⌊nPj⌋,j−1)−g(Pj−1,j−1)]g(n,j)=g(n,j-1)-f&#x27;(P_j)[g(\\lfloor\\dfrac{n}{P_j}\\rfloor,j-1)-g(P_j-1,j-1)]g(n,j)=g(n,j−1)−f′(Pj​)[g(⌊Pj​n​⌋,j−1)−g(Pj​−1,j−1)]（因为 g(⌊nPj⌋,j−1)g(\\lfloor\\dfrac{n}{P_j}\\rfloor,j-1)g(⌊Pj​n​⌋,j−1) 中还计算了 2,3,⋯ ,pj−12,3,\\cdots,p_j-12,3,⋯,pj​−1 种的素数的值所以扣去）。 g(Pj−1,j−1)g(P_j-1,j-1)g(Pj​−1,j−1) 可以直接求出，不需要单独计算（Pj2≤nP_j^2\\leq nPj2​≤n，就是一个素数位置的值的前缀和）。 由于 ggg 的第一维是每次是除一个数下取整，而 ⌊⌊na⌋b⌋=⌊nab⌋\\lfloor\\dfrac{\\lfloor\\frac{n}{a}\\rfloor}{b}\\rfloor=\\lfloor\\dfrac{n}{ab}\\rfloor⌊b⌊an​⌋​⌋=⌊abn​⌋，所以第一维可以只记录形如 ⌊nx⌋\\lfloor\\dfrac{n}{x}\\rfloor⌊xn​⌋ 的值。 第二步 求出了 GGG 之后如何计算答案。 类似地，设 S(n,j)S(n,j)S(n,j) 表示 2,3,⋯ ,n2,3,\\cdots,n2,3,⋯,n 这些数中，iii 的最小素因子大于 PjP_jPj​ 的 f(i)f(i)f(i) 之和，将 111 的贡献单独算，则 ans=S(n,1)ans=S(n,1)ans=S(n,1)。 具体地： S(n,j)=∑i=2n[minp⁡(i)&gt;Pj]f(i)S(n,j)=\\sum_{i=2}^n[\\operatorname{minp}(i)\\gt P_j]f(i) S(n,j)=i=2∑n​[minp(i)&gt;Pj​]f(i) 考虑仍然使用 dpdpdp 计算， S(n,j)=G(n)−∑i=1j−1f(Pi)+∑k≥j∑e≥1,Pke≤nf(Pke)(S(⌊nPke⌋,k+1)+[e&gt;1])S(n,j)=G(n)-\\sum_{i=1}^{j-1}f(P_i)+\\sum_{k\\ge j}\\sum_{e\\geq 1,P_k^e\\leq n}f(P_k^e)(S(\\lfloor\\frac{n}{P_k^e}\\rfloor,k+1)+[e\\gt 1]) S(n,j)=G(n)−i=1∑j−1​f(Pi​)+k≥j∑​e≥1,Pke​≤n∑​f(Pke​)(S(⌊Pke​n​⌋,k+1)+[e&gt;1]) 应用 计算素数个数函数 π(n)\\pi(n)π(n) 只需要用到第一步，fff 函数满足素数位置的值为 111。 直接按照第一步的步骤做即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll n,l,g[2100000]; int tot,p[2100000]; bool vis[2100000]; int cnt,pos1[2100000],pos2[2100000]; ll num[2100000]; void Sieve(int n){ vis[1]=1; for (int i=2;i&lt;=n;i++){ if (!vis[i]) p[++tot]=i; for (int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;j++){ vis[i*p[j]]=true; if (!(i%p[j])) break; } } } int calc(ll x){ return x&lt;=l?pos1[x]:pos2[n/x];} void upd(ll x){ num[++cnt]=x; g[cnt]=x-1; if (x&lt;=l) pos1[x]=cnt; else pos2[n/x]=cnt; } int main(){ scanf(&quot;%lld&quot;,&amp;n); l=1; while (l*l&lt;=n) l++; l--; Sieve(l); for (ll i=1,j;i&lt;=n;i=j+1){ j=n/(n/i); upd(n/i); } for (int j=1;j&lt;=tot;j++) for (int i=1;1ll*p[j]*p[j]&lt;=num[i];i++) g[i]-=(g[calc(num[i]/p[j])]-(j-1)); printf(&quot;%lld\\n&quot;,g[1]); return 0; } ","link":"https://hydd-new.github.io/min-25/"},{"title":"CF1204D","content":" 给定一个 01 串 sss，要求你找到一个与 sss 长度相等的 01 串 ttt 并满足以下条件： 对于任意的 l,r(1≤l≤r≤n)l,r(1\\leq l\\leq r\\leq n)l,r(1≤l≤r≤n)，s[l:r]s[l:r]s[l:r] 和 t[l:r]t[l:r]t[l:r] 的最长不下降子序列长度相同； ttt 中 000 的数量尽可能多。 有多解输出任意一种。∣S∣≤105|S|\\leq 10^5∣S∣≤105。 sol 这个题非常有意思。容易想到按照一个顺序依次确定每个位置的值。 但是前面的位置确定了，当前位置的值不仅和之前的最长不下降子序列长度有关，还和 111 的个数有关。 发现 10 是不能被其它等长的串所替换的，它的最长不下降子序列长度为 111，而其它等长的串都为 222。 有一个思路（猜测），就是把串中的 10 不断删除，直到不存在。但这样真的行吗？ 删除某个 10 后对所有 l,rl,rl,r 最长不下降子序列长度的影响： l,rl,rl,r 完全包含被删除的 10，那么原先无论最长不下降子序列是怎么选的，都一定会选择 10 中的恰好一个数，现在它的长度必定减少 1； l,rl,rl,r 和 被删除的 10 无交，那么最长不下降子序列长度不影响； l,rl,rl,r 和 被删除的 10 有交但不包含，即 lll 或 rrr 在 10 之间，如果是 lll 则原子序列一定会选择最左边的 000，如果是 rrr 则原子序列一定会选择最右边的 111，删去后长度必定减少 1。 删去后的问题，如果 s′s&#x27;s′ 和 t′t&#x27;t′ 满足条件，那么加回这个 10 后仍然满足条件。 所以可以一直删去 10，直到没有 10。考虑现在的串一定为 00...011...1，可以把所有数字都变成 000，所有 l,rl,rl,r 最长不下降子序列长度不变。 具体实现可以从左到右扫描，维护一个栈记录之前还没被删去的 111 的位置，如果当前为 000 且栈不为空则可以和前面的一起删去，否则加入栈。最后栈中的 111 即没有被删去的 111，都变为 000 即可。 #include&lt;bits/stdc++.h&gt; using namespace std; string s; int top,t[110000]; int main(){ cin&gt;&gt;s; int n=s.length(); for (int i=0;i&lt;n;i++) if (s[i]=='1') t[++top]=i; else if (top) top--; while (top) s[t[top--]]='0'; cout&lt;&lt;s&lt;&lt;endl; return 0; } ","link":"https://hydd-new.github.io/CF1204D/"},{"title":"CF1365F","content":" 给定 nnn 和数字串 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​，b1,b2,⋯ ,bnb_1,b_2,\\cdots,b_nb1​,b2​,⋯,bn​。 定义一次操作为：将一个等长且不相交的前缀和后缀对应位置交换。举例：{1,2,3,4,5,6}\\{1,2,3,4,5,6\\}{1,2,3,4,5,6} 交换长度为 222 的前后缀变为 {5,6,3,4,1,2}\\{5,6,3,4,1,2\\}{5,6,3,4,1,2}。 可以对 aaa 进行任意次操作，问是否能变成 bbb。多组数据。 1≤T≤500,1≤n≤500,1≤ai,bi≤1091\\leq T\\leq 500,1\\leq n\\leq 500,1\\leq a_i,b_i\\leq 10^91≤T≤500,1≤n≤500,1≤ai​,bi​≤109。 sol 一个显然的结论：如果 nnn 为奇数，则两个串 n+12\\frac {n+1}22n+1​ 位置必须相同（因为不能翻转）。 我们称下标和为 n+1n+1n+1 的数是对应的（换句话说，第 iii 个位置的数和第 n−i+1n-i+1n−i+1 位置的数是对应的），那么可以发现，对应位置形成的无序对是永远不会改变的（对于左边的数 iii 移动到 i+(n−k)i+(n-k)i+(n−k)，对于右边的数 n−i+1n-i+1n−i+1 移动到 n−i+1−(n−k)n-i+1-(n-k)n−i+1−(n−k)，它们之和依旧为 n+1n+1n+1）。 于是大胆猜测原问题等价于是否满足 a,ba,ba,b 无序对相同。 证明 首先，上述结论是必要的。 其次，若对于满足上述结论的 aaa，能构造出合法的操作序列，那么原问题和 aaa 是否满足上述结论是等价的。接下来需要构造操作序列。 朴素的想法是从中间到两边依次确定，因为固定住中间不影响后续操作，且固定后不影响上述结论是否成立（删除了相同的无序对不影响结论）。 考虑现在固定 ai,an−i+1a_i,a_{n-i+1}ai​,an−i+1​，找相同的无序对 aj,an−j+1a_j,a_{n-j+1}aj​,an−j+1​ 移动过来。设 ai=aja_i=a_jai​=aj​，分情况讨论： j=nj=nj=n，那么直接翻转长度为 iii 的前后缀，那么 ana_nan​ 翻到 aia_iai​，a1a_1a1​ 翻到 an−i+1a_{n-i+1}an−i+1​，满足条件； j=1j=1j=1，那么直接翻转长度为 111 的前后缀，就变成 1. 的情况了； 其它，那么翻转长度为 j(n−j+1)j(n-j+1)j(n−j+1) 的前后缀，那么 jjj 就变成 1./2. 的情况了。 这样就变成规模更小的子问题了，所以证明了满足上述条件即成立。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; pii; int T,n,a[510],b[510]; pii x[510],y[510]; bool check(){ int m=(n&gt;&gt;1)+1; if ((n&amp;1)&amp;&amp;a[m]!=b[m]) return false; for (int i=1;i&lt;m;i++){ x[i]=pii(min(a[i],a[n-i+1]),max(a[i],a[n-i+1])); y[i]=pii(min(b[i],b[n-i+1]),max(b[i],b[n-i+1])); } sort(x+1,x+m); sort(y+1,y+m); for (int i=1;i&lt;m;i++) if (x[i]!=y[i]) return false; return true; } int main(){ scanf(&quot;%d&quot;,&amp;T); while (T--){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); if (check()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0; } ","link":"https://hydd-new.github.io/CF1365F/"},{"title":"UOJ682","content":" 给定 nnn 和序列 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​，b1,b2,⋯bnb_1,b_2,\\cdots b_nb1​,b2​,⋯bn​。 定义一个区间 [l,r][l,r][l,r] 的权值为：对于所有满足 pi∈{ai,bi}p_i\\in \\{a_i,b_i\\}pi​∈{ai​,bi​}，⊕i=lrpi\\oplus_{i=l}^r p_i⊕i=lr​pi​ 的序列 p1,p2,⋯pnp_1,p_2,\\cdots p_np1​,p2​,⋯pn​ 的最大值。 求左右端点满足 1≤l≤r≤n1\\leq l\\leq r\\leq n1≤l≤r≤n 的区间中，第 kkk 小的权值是多少（可重）。 1≤n≤105,0≤ai,bi&lt;230,1≤k≤n(n+1)21\\leq n\\leq 10^5,0\\leq a_i,b_i\\lt 2^{30},1\\leq k\\leq \\frac{n(n+1)}21≤n≤105,0≤ai​,bi​&lt;230,1≤k≤2n(n+1)​。 sol 初步思考 这种题目比较容易想到线性基。 但是线性基是其中每个数都可以选或不选，而这题是类似于连续区间二选一。 线性基就不能做了吗？当然不是，假设刚开始全部选 aaa，那么选择一些位置把它变成 bbb 这种类型就是线性基能做的了。 问题转化 记 ci=ai⊕bi,si=⊕j=1iajc_i=a_i\\oplus b_i,s_i=\\oplus_{j=1}^i a_jci​=ai​⊕bi​,si​=⊕j=1i​aj​，区间 [l,r][l,r][l,r] 的权值转化为：sr⊕sl−1s_r\\oplus s_{l-1}sr​⊕sl−1​ 再异或上若干个 cic_ici​ 的最大值。 线性基求和 xxx 异或的最大值的方法为：从高到低枚举每一位，若这一位 xxx 为 000，则异或上线性基上这一位的数。 设 f(x,T)=max⁡y∈T(x⊕y)f(x,T)=\\max_{y\\in T}(x\\oplus y)f(x,T)=maxy∈T​(x⊕y)，其中 xxx 是一个数，TTT 是一个线性基。 暴力做法：固定左端点 lll，移动右端点 rrr 时维护线性基 TTT，求出每个区间的权值 f(sr⊕sl−1,T)f(s_r\\oplus s_{l-1},T)f(sr​⊕sl−1​,T)，最后求第 kkk 小值。 继续思考 考虑优化暴力做法。固定左端点，由于线性基维数不超过 mmm，故不同的右端点本质不同的线性基至多有 m+1m+1m+1 种（即维数分别为 0,1,⋯m0,1,\\cdots m0,1,⋯m）。移动右端点时，线性基维数可能增加 111，也有可能不增加。 考虑改为：对于右端点 rrr，维护所有左端点为 1,2,⋯ ,r1,2,\\cdots,r1,2,⋯,r 的线性基。右端点从 r−1r-1r−1 移动到 rrr 时，一定是一个后缀 p,p+1,⋯ ,rp,p+1,\\cdots,rp,p+1,⋯,r 的线性基维数 +1+1+1，可以直接暴力更新，复杂度 O(nm2)O(nm^2)O(nm2)。 现在求的 f(sr⊕sl−1,Tl,r)f(s_r\\oplus s_{l-1},T_{l,r})f(sr​⊕sl−1​,Tl,r​) 和 l,rl,rl,r 都有关，虽然在移动右端点时维护出了不同的 TTT，但是带入无法解决。 设 g(x,T)=min⁡y∈T(x⊕y)g(x,T)=\\min_{y\\in T}(x\\oplus y)g(x,T)=miny∈T​(x⊕y)，由于 fff 相当于 xxx 某位为 111 就异或那一位的线性基上的值，ggg 相当于 xxx 某位为 000 就异或那一位的线性基上的值，那么 f(sr⊕sl−1,Tl,r)f(s_r\\oplus s_{l-1},T_{l,r})f(sr​⊕sl−1​,Tl,r​) 等于 f(sr,Tl,r)⊕g(sl−1,Tl,r)f(s_r,T_{l,r})\\oplus g(s_{l-1},T_{l,r})f(sr​,Tl,r​)⊕g(sl−1​,Tl,r​)。 现在 Tl,rT_{l,r}Tl,r​ 可以增量维护，和右端点移动无关的 f(sr⊕sl−1,Tl,r)f(s_r\\oplus s_{l-1},T_{l,r})f(sr​⊕sl−1​,Tl,r​) 就能维护了，而和右端点移动有关的 g(sr,Tl,r)⊕g(sl−1,Tl,r)g(s_r,T_{l,r})\\oplus g(s_{l-1},T_{l,r})g(sr​,Tl,r​)⊕g(sl−1​,Tl,r​) 由于本质不同的只有最多 mmm 个，所以可以每次暴力重新求。 上述实现 lv[x][l]lv[x][l]lv[x][l] 表示基大小为 xxx，左端点为 lll 时代入 s[l−1]s[l-1]s[l−1] 的最小值。 rv[x][r]rv[x][r]rv[x][r] 表示基大小为 xxx，右端点为 rrr 时代入 s[r]s[r]s[r] 的最大值。 lp[x][r]/rp[x][r]lp[x][r]/rp[x][r]lp[x][r]/rp[x][r] 表示基大小为 xxx，右端点为 rrr 时左端点合法区间的左右端点。 具体来说，lvlvlv 可以通过暴力往左枚举左端点，加入当前数扩大线性基，直到发现当前左端点当前数不能扩大线性基就停止。rv/lp/rprv/lp/rprv/lp/rp 可以维护满足 i..ri..ri..r 基大小为 xxx 的最大的 rrr，在这些位置加入当前数扩大线性基合并。 求解答案 二进制从高到低确定每一位，假设当前确定到从高到低第 www 位。 枚举基大小，对于不同的右端点，求出合法左端点区间中，ggg 和当前右端点 fff 值前 www 位相同的数的数量，具体实现使用 two-pointers。 求和后和 kkk 比较，如果 &lt;k&lt;k&lt;k，说明答案这位为 111，将 kkk 减去当前数量，并将所有 fff 的这一位异或（即之后要找这一位不同的）。 //40pts #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int m=30; int n,a[110000],b[110000],c[110000],s[110000]; ll k; int lv[32][110000],rv[32][110000],lp[32][110000],rp[32][110000],v[32][110000]; unordered_map&lt;int,int&gt; mp; struct Basis{ int tot,v[32]; Basis(){ tot=0; memset(v,0,sizeof(v));} bool ins(int x){ for (int i=m-1;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1) x^=v[i]; for (int i=m-1;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1){ v[i]=x; tot++; for (int j=m-1;j&gt;i;j--) if ((v[j]&gt;&gt;i)&amp;1) v[j]^=x; return true; } return false; } int querymax(int x){ for (int i=m-1;i&gt;=0;i--) if (!((x&gt;&gt;i)&amp;1)) x^=v[i]; return x; } int querymin(int x){ for (int i=m-1;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1) x^=v[i]; return x; } } A[110000],B[110000]; vector&lt;int&gt; p,q; void upd(int i){ A[i].ins(c[i]); for (int x:p) A[x].ins(c[i]); q=p; p.clear(); p.push_back(i); for (int x:q) if (A[x].tot&gt;A[p.back()].tot) p.push_back(x); } int main(){ scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); s[i]=s[i-1]^a[i]; } for (int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;b[i]); c[i]=a[i]^b[i]; } for (int i=1;i&lt;=n;i++){ for (int j=i;j&gt;=1&amp;&amp;(B[j].ins(c[i])||i==j);j--) lv[B[j].tot][j]=B[j].querymin(s[j-1]); upd(i); for (int j=0;j&lt;(int)p.size();j++){ rv[A[p[j]].tot][i]=A[p[j]].querymax(s[i]); lp[A[p[j]].tot][i]=(j+1&lt;(int)p.size()?p[j+1]+1:1); rp[A[p[j]].tot][i]=p[j]; } } int ans=0; for (int i=m-1;i&gt;=0;i--){ for (int j=0;j&lt;=m;j++) for (int k=1;k&lt;=n;k++) v[j][k]=((v[j][k]&lt;&lt;1)|(rv[j][k]&gt;&gt;i&amp;1)); ll tot=0; for (int j=0;j&lt;=m;j++){ mp.clear(); int l=1,r=0; for (int k=1;k&lt;=n;k++){ if (!lp[j][k]) continue; while (l&lt;lp[j][k]) mp[lv[j][l++]&gt;&gt;i]--; while (r&lt;rp[j][k]) mp[lv[j][++r]&gt;&gt;i]++; tot+=mp[v[j][k]]; } } int c=(tot&lt;k); if (c) k-=tot; for (int j=0;j&lt;=m;j++) for (int k=1;k&lt;=n;k++) v[j][k]^=c; ans=(ans&lt;&lt;1|c); } printf(&quot;%d\\n&quot;,ans); return 0; } 发现 TLE 了，因为直接这样子做常数非常大，因为求相同的数的数量时，f/gf/gf/g 值可能很大，需要使用 map/unorderedmapmap/unordered_mapmap/unorderedm​ap 或 手写哈希表 等数据结构。 怎么办呢，可以发现，这一位做完后，前几位再也不会修改了，所以可以将前几位重标号，这样就可以通过此题，时间复杂度 O(nm2)O(nm^2)O(nm2)。 //Accepted #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int m=30; int n,c[110000],s[110000],mp[4100000],num[4100000],val[4100000]; ll k; int lv[32][110000],rv[32][110000],lp[32][110000],rp[32][110000],u[32][110000],v[32][110000]; struct Basis{ int tot,v[32]; Basis(){ tot=0; memset(v,0,sizeof(v));} bool ins(int x){ for (int i=m-1;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1) x^=v[i]; for (int i=m-1;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1){ v[i]=x; tot++; for (int j=m-1;j&gt;i;j--) if ((v[j]&gt;&gt;i)&amp;1) v[j]^=x; return true; } return false; } int querymax(int x){ for (int i=m-1;i&gt;=0;i--) if (!((x&gt;&gt;i)&amp;1)) x^=v[i]; return x; } int querymin(int x){ for (int i=m-1;i&gt;=0;i--) if ((x&gt;&gt;i)&amp;1) x^=v[i]; return x; } } A[110000],B[110000]; vector&lt;int&gt; p,q; void upd(int i){ A[i].ins(c[i]); for (int x:p) A[x].ins(c[i]); q=p; p.clear(); p.push_back(i); for (int x:q) if (A[x].tot&gt;A[p.back()].tot) p.push_back(x); } int main(){ scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;s[i]); for (int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;c[i]); c[i]^=s[i]; s[i]^=s[i-1]; } for (int i=1;i&lt;=n;i++){ for (int j=i;j&gt;=1&amp;&amp;(B[j].ins(c[i])||i==j);j--) lv[B[j].tot][j]=B[j].querymin(s[j-1]); upd(i); for (int j=0;j&lt;(int)p.size();j++){ rv[A[p[j]].tot][i]=A[p[j]].querymax(s[i]); lp[A[p[j]].tot][i]=(j+1&lt;(int)p.size()?p[j+1]+1:1); rp[A[p[j]].tot][i]=p[j]; } } int ans=0; for (int i=m-1;i&gt;=0;i--){ for (int j=0;j&lt;=m;j++) for (int k=1;k&lt;=n;k++){ v[j][k]=((v[j][k]&lt;&lt;1)|(rv[j][k]&gt;&gt;i&amp;1)); u[j][k]=((u[j][k]&lt;&lt;1)|(lv[j][k]&gt;&gt;i&amp;1)); } ll tot=0; for (int j=0;j&lt;=m;j++){ int l=1,r=0; for (int k=1;k&lt;=n;k++){ if (!lp[j][k]) continue; while (l&lt;lp[j][k]) mp[u[j][l++]]--; while (r&lt;rp[j][k]) mp[u[j][++r]]++; tot+=mp[v[j][k]]; } for (int k=l;k&lt;=r;k++) mp[u[j][k]]=0; } int c=(tot&lt;k); if (c) k-=tot; int now=0; for (int j=0;j&lt;=m;j++) for (int k=1;k&lt;=n;k++){ v[j][k]^=c; if (!num[v[j][k]]) now++,num[v[j][k]]=now,val[now]=v[j][k]; v[j][k]=num[v[j][k]]; } for (int j=0;j&lt;=m;j++) for (int k=1;k&lt;=n;k++) if (num[u[j][k]]) u[j][k]=num[u[j][k]]; else u[j][k]=0; while (now) num[val[now--]]=0; ans=(ans&lt;&lt;1|c); } printf(&quot;%d\\n&quot;,ans); return 0; } ","link":"https://hydd-new.github.io/UOJ682/"},{"title":"UOJ681","content":" 给定 nnn 个数字 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​。 mmm 次询问，每次询问给定 xxx，求 ⊕i=1n(ai+x)\\oplus_{i=1}^n (a_i+x)⊕i=1n​(ai​+x) 的值。 强制在线。 1≤n,m≤2.5×105,0≤ai,x&lt;2601\\leq n,m\\leq 2.5\\times 10^5,0\\leq a_i,x\\lt 2^{60}1≤n,m≤2.5×105,0≤ai​,x&lt;260。 sol 由于每个 aia_iai​ 加的都是 xxx，所以向第 www 位进位的一定是后 w−1w-1w−1 位 aia_iai​ 最大的若干个数。 从低到高考虑每一位。讨论 xxx 当前这一位是 000 还是 111。 如果当前位为 0： ai+xa_i+xai​+x 当前位为 111 的数量：进位为 000 且 xxx 当前位为 111 的数量 + 进位为 111 且 xxx 当前位为 000 的数量； ai+xa_i+xai​+x 向前进位的数量：进位为 111 且 xxx 当前位为 111 的数量。 如果当前位为 1： ai+xa_i+xai​+x 当前位为 111 的数量：进位为 111 且 xxx 当前位为 111 的数量 + 进位为 000 且 xxx 当前位为 000 的数量； ai+xa_i+xai​+x 没向前进位的数量：进位为 000 且 xxx 当前位为 000 的数量，向前进位的数量用 nnn 减去即可。 记 sum[0/1][w][i]sum[0/1][w][i]sum[0/1][w][i] 为考虑后 w−1w-1w−1 位有 iii 个数进位，第 iii 位没进位/进位的数的个数。 可以用基数排序优化每次的排序。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=1ll&lt;&lt;60; int n,m,t,sum[2][64][260000],tmp[2][260000],p[260000]; ll ans,v,a[260000]; int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),p[i]=i; for (int w=0;w&lt;62;w++){ tmp[0][0]=0; tmp[1][0]=0; for (int i=1;i&lt;=n;i++){ int x=(a[p[i]]&gt;&gt;w)&amp;1; tmp[x][++tmp[x][0]]=p[i]; sum[0][w][i]=tmp[0][0]; sum[1][w][i]=tmp[1][0]; } for (int i=1;i&lt;=tmp[0][0];i++) p[i]=tmp[0][i]; for (int i=1;i&lt;=tmp[1][0];i++) p[i+tmp[0][0]]=tmp[1][i]; } for (int i=1;i&lt;=m;i++){ scanf(&quot;%lld&quot;,&amp;v); v^=(t*(ans&gt;&gt;20)); int x=0; ans=0; for (int w=0;w&lt;62;w++) if ((v&gt;&gt;w)&amp;1){ ans^=(((sum[1][w][n]-sum[1][w][n-x])+sum[0][w][n-x])&amp;1ll)&lt;&lt;w; x=n-sum[0][w][n-x]; } else{ ans^=(((sum[0][w][n]-sum[0][w][n-x])+sum[1][w][n-x])&amp;1ll)&lt;&lt;w; x=sum[1][w][n]-sum[1][w][n-x]; } printf(&quot;%lld\\n&quot;,ans); } return 0; } ","link":"https://hydd-new.github.io/UOJ681/"},{"title":"AGC048C","content":" 给你 N,LN,LN,L 和序列 0=A0&lt;A1&lt;A2&lt;⋯&lt;An≤An+1=L+1,0=B0&lt;B1&lt;B2&lt;⋯&lt;Bn≤Bn+1=L+10=A_0&lt;A_1&lt;A_2&lt;\\cdots&lt;A_n\\leq A_{n+1}=L+1,0=B_0&lt;B_1&lt;B_2&lt;\\cdots&lt;B_n\\leq B_{n+1}=L+10=A0​&lt;A1​&lt;A2​&lt;⋯&lt;An​≤An+1​=L+1,0=B0​&lt;B1​&lt;B2​&lt;⋯&lt;Bn​≤Bn+1​=L+1。 每次可以选择一个数 x(1≤x≤N)x(1\\leq x\\leq N)x(1≤x≤N)，使得 Ax=Ax−1+1A_x=A_{x-1}+1Ax​=Ax−1​+1 或 Ax=Ax+1−1A_x=A_{x+1}-1Ax​=Ax+1​−1。 问把 AAA 变成 BBB 的最少次数，无解输出 −1-1−1。 1≤N≤105,N≤L≤1091\\leq N\\leq 10^5,N\\leq L\\leq 10^91≤N≤105,N≤L≤109。 sol #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int n,m,a[110000],b[110000],x[110000],y[110000]; void read(int *a,int *b,int &amp;cnt){ a[0]=0; a[n+1]=m+1; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for (int i=n+1;i&gt;=1;i--) a[i]-=a[i-1]+1; for (int i=1;i&lt;=n+1;i++) if (a[i]) b[++cnt]=i; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int cnt1=0,cnt2=0; read(a,x,cnt1); read(b,y,cnt2); ll ans=0; int j=1; for (int i=1;i&lt;=cnt2;i++){ int sum=0,l=x[j],r; while (j&lt;=cnt1&amp;&amp;sum&lt;b[y[i]]) sum+=a[x[j++]]; r=x[j-1]; ans+=r-l; if (sum!=b[y[i]]){ puts(&quot;-1&quot;); return 0;} if (y[i]&lt;l) ans+=l-y[i]; else if (r&lt;y[i]) ans+=y[i]-r; } if (j&lt;=cnt1) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;,ans); return 0; } Note ans 需要开 long long ","link":"https://hydd-new.github.io/AGC048C/"},{"title":"AGC048B","content":" 设一个由小括号和中括号组成的串 SSS 的权值为 ∑Si∈{’(’,’)’}Ai+∑Si∈{’[’,’]’}Bi\\sum_{S_i\\in\\{\\texttt{&#x27;(&#x27;,&#x27;)&#x27;}\\}} A_i+\\sum_{S_i\\in\\{\\texttt{&#x27;[&#x27;,&#x27;]&#x27;}\\}} B_i∑Si​∈{’(’,’)’}​Ai​+∑Si​∈{’[’,’]’}​Bi​。 求所有的合法的由小括号和中括号组成的长度为 NNN 的串中最大的权值是多少。 2≤N≤105,2∣N,1≤Ai,Bi≤1092\\leq N\\leq 10^5,2\\mid N,1\\leq A_i,B_i\\leq 10^92≤N≤105,2∣N,1≤Ai​,Bi​≤109。 sol #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int n,a[110000],b[2][51000]; int main(){ scanf(&quot;%d&quot;,&amp;n); ll ans=0; for (int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); ans+=a[i]; } int x; for (int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;x); x-=a[i]; b[i&amp;1][i&gt;&gt;1]=x; } sort(b[0],b[0]+(n&gt;&gt;1),greater&lt;int&gt;()); sort(b[1],b[1]+(n&gt;&gt;1),greater&lt;int&gt;()); for (int i=0;i&lt;(n&gt;&gt;1);i++)//not n if (b[0][i]+b[1][i]&gt;0) ans+=b[0][i]+b[1][i]; else break; printf(&quot;%lld\\n&quot;,ans); return 0; } Note 将代码里注释那一行的 n&gt;&gt;1 写成 n 可能导致RE ans 需要开 long long ","link":"https://hydd-new.github.io/AGC048B/"},{"title":"AGC048A","content":" 给定一个小写字母组成的字符串 SSS，每次操作可以交换相邻两个字符。 问最少需要多少次操作，使得 S 的字典序严格大于 atcoder，无解输出 -1。 有 TTT 组数据，1≤T≤100,1≤∣S∣≤10001\\leq T\\leq 100,1\\leq |S|\\leq 10001≤T≤100,1≤∣S∣≤1000。 sol #include&lt;bits/stdc++.h&gt; using namespace std; const char t[8]={'a','t','c','o','d','e','r',0}; int T,n; char s[1100]; int main(){ scanf(&quot;%d&quot;,&amp;T); while (T--){ for (int i=0;i&lt;8;i++) s[i]=0; scanf(&quot;%s&quot;,s); n=strlen(s); bool flag=false; for (int i=0;i&lt;8;i++) if (t[i]!=s[i]){ flag=(t[i]&lt;s[i]); break; } if (flag){ puts(&quot;0&quot;); continue;} int pos=-1; for (int i=0;i&lt;n;i++) if (s[i]!='a'){ pos=i; break; } if (pos==-1){ puts(&quot;-1&quot;); continue;} printf(&quot;%d\\n&quot;,pos-1+(s[pos]&lt;='t')); } return 0; } ","link":"https://hydd-new.github.io/AGC048A/"},{"title":"模板","content":" 普通幂转第二类斯特林数：$ik=\\sum\\limits_{j=1}{i}S_{k,j}\\times C_{i,j}\\times j! $。 第二类斯特林数求自然数幂和：∑i=0nik=∑j=1nSk,j×j!×Cn+1,j+1\\sum\\limits^n_{i = 0}i ^ k = \\sum \\limits _ {j = 1} ^ n S_{k, j}\\times j! \\times C_{n + 1, j + 1}i=0∑n​ik=j=1∑n​Sk,j​×j!×Cn+1,j+1​。 min−max\\rm min-maxmin−max容斥：max⁡(S)=∑T⊆S(−1)∣T∣+1min⁡(T)\\max(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\min(T)max(S)=∑T⊆S​(−1)∣T∣+1min(T)，min⁡(S)=∑T⊆S(−1)∣T∣+1max⁡(T)\\min(S)=\\sum_{T \\subseteq S}(-1)^{|T|+1}\\max(T)min(S)=∑T⊆S​(−1)∣T∣+1max(T) gcd⁡−lcm\\gcd-\\mathrm{lcm}gcd−lcm容斥：lcm(T)=∏S∈Tgcd⁡(S)(−1)∣S∣+1\\mathrm{lcm}(T)=\\prod_{S\\in T}\\gcd(S)^{(-1)^{|S|+1}}lcm(T)=∏S∈T​gcd(S)(−1)∣S∣+1 多项式开根：若B′2(x)≡A(x)(mod xn2)B&#x27;^2(x)\\equiv A(x) (mod\\ x^{\\frac{n}{2}})B′2(x)≡A(x)(mod x2n​)，B2(x)≡A(x)(mod xn)B^2(x)\\equiv A(x) (mod\\ x^{n})B2(x)≡A(x)(mod xn)，则有以下等式成立：B(x)≡A(x)+B′2(x)2B′(x)(mod xn)B(x)\\equiv \\dfrac{A(x)+B&#x27;^2(x)}{2B&#x27;(x)} (mod\\ x^n)B(x)≡2B′(x)A(x)+B′2(x)​(mod xn)。 0. IO/数学 0.1 读入优化 char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } char readop(){ char ch=Getchar(); while (ch&lt;'A'||ch&gt;'Z') ch=Getchar(); return ch; } 0.2 输出优化 char pbuf[100000],*pp=pbuf; void pc(const char c) { if (pp-pbuf==100000) fwrite(pbuf,1,100000,stdout),pp=pbuf; *pp++=c; } void write(int x) { static int sta[35]; if (x&lt;0){ pc('-'); x=-x; } int top=0; do{ sta[top++]=x%10; x/=10; } while(x); while (top) pc(sta[--top]+'0'); } void myfflush(){ fwrite(pbuf,1,pp-pbuf,stdout); } 0.3 取模优化 inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} 1. 数论 1.1 预处理阶乘和阶乘逆元 fac[0]=1; for (int i=1;i&lt;=10000000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=10000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=10000000;i++) inv[i]=inv[i-1]*inv[i]%Mod; ll C(int n,int m){ if (n&lt;m) return 0; return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod; } 1.2 快速幂 ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } 1.3 gcd&amp;lcm int gcd(int a,int b){ if (!b) return a; return gcd(b,a%b); } int lcm(int a,int b){ return 1ll*a/gcd(a,b)*b;} 1.4 CRT #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; int n; ll a[11],b[11]; ll mult(ll a,ll b,ll mod){ if (a&lt;b) swap(a,b); ll ans=0; while (b){ if (b&amp;1) ans=(ans+a)%mod; a=(a&lt;&lt;1)%mod; b&gt;&gt;=1; } return ans; } void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if (!b){ x=1; y=0; return; } exgcd(b,a%b,x,y); ll tmp=x; x=y; y=tmp-a/b*y; } ll CRT(int n){ ll x,y; ll ans=0,lcm=1; for (int i=1;i&lt;=n;i++) lcm*=b[i]; for (int i=1;i&lt;=n;i++){ ll tmp=lcm/b[i]; exgcd(tmp,b[i],x,y); x=(x%b[i]+b[i])%b[i]; ans=(ans+mult(mult(tmp,x,lcm),a[i],lcm))%lcm; } return (ans+lcm)%lcm; } int main(){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;b[i]); a[i]=(a[i]%b[i]+b[i])%b[i]; } printf(&quot;%lld\\n&quot;,CRT(n)); return 0; } 1.5 exgcd&amp;excrt 考虑合并两个方程 x≡a1(mod⁡m1),x≡a2(mod⁡m2)x\\equiv a_1(\\operatorname{mod} m_1),x\\equiv a_2(\\operatorname{mod} m_2)x≡a1​(modm1​),x≡a2​(modm2​)。 那么，有 x=a1+k1×m1,x=a2+k2×m2x=a_1+k_1\\times m_1,x=a_2+k_2\\times m_2x=a1​+k1​×m1​,x=a2​+k2​×m2​。 k2×m2−k1×m1=a1−a2k_2\\times m_2-k_1\\times m_1=a_1-a_2k2​×m2​−k1​×m1​=a1​−a2​。 令 c=a1−a2c=a_1-a_2c=a1​−a2​，g=gcd(m2,m1)g=gcd(m_2,m_1)g=gcd(m2​,m1​)。 那么，若 g∤cg\\nmid cg∤c，则方程无解。否则 g∣c,cg∈Zg\\mid c,\\frac{c}{g}\\in \\mathcal{Z}g∣c,gc​∈Z。 我们可以用 exgcdexgcdexgcd 求出 k2′×m2+k1′×m1=gk_2&#x27;\\times m_2+k_1&#x27;\\times m_1=gk2′​×m2​+k1′​×m1​=g 中满足条件的 k1′k_1&#x27;k1′​。 将两边同时乘 cg\\frac{c}{g}gc​，即 k1′,k2′k_1&#x27;,k_2&#x27;k1′​,k2′​ 乘上 cg\\frac cggc​，右边变成 ccc 。 我们得到了 k2′×m2+k1′×m1=ck_2&#x27;\\times m_2+k_1&#x27;\\times m_1=ck2′​×m2​+k1′​×m1​=c 的解 k1′k_1&#x27;k1′​。可以将 k1′mod m2k_1&#x27; \\mod m_2k1′​modm2​。 但是注意，我们的原方程是 k2×m2−k1×m1=a1−a2k_2\\times m_2-k_1\\times m_1=a_1-a_2k2​×m2​−k1​×m1​=a1​−a2​，故 k1=−k1′k_1=-k_1&#x27;k1​=−k1′​。 也就是 x=a1−k1′×m1x=a_1-k_1&#x27;\\times m_1x=a1​−k1′​×m1​。我们就求出了一个解 x0x_0x0​。那么通解是 x≡x0(mod⁡lcm⁡(m1,m2))x\\equiv x_0(\\operatorname{mod} \\operatorname{lcm}(m_1,m_2))x≡x0​(modlcm(m1​,m2​))。 typedef long long ll; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if (!b){ x=1; y=0; return a; } ll g=exgcd(b,a%b,y,x); y-=a/b*x; return g; } ll a[N],m[N]; ll excrt(){ ll M=m[1],A=a[1],x,y,d; for (int i=2;i&lt;=n;i++){ d=exgcd(M,m[i],x,y); if ((A-a[i])%d) return -1; x=(A-a[i])/d*x%m[i]; A-=M*x; M=M/d*m[i]; A%=M; } return (A%M+M)%M; } 1.6 Pollard Rho 输出 nnn 的最大质因子（1⩽n⩽10181\\leqslant n\\leqslant 10^{18}1⩽n⩽1018） #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;ctime&gt; #include&lt;algorithm&gt; #define ctz __builtin_ctzll using namespace std; typedef long long ll; ll ans; /*inline ll mul(ll x,ll y,ll Mod){ ll ret=x*y-((ll)((long double)x/Mod*y+0.5))*Mod; return (ret%Mod+Mod)%Mod; }*/ inline ll mul(ll x,ll y,ll p){ return (__int128)x*y%p; } inline ll qpow(ll x,ll a,ll Mod){ ll res=1; while (a){ if (a&amp;1) res=mul(res,x,Mod); x=mul(x,x,Mod); a&gt;&gt;=1; } return res; } inline ll rdm(){ return 1ll*rand()&lt;&lt;31|rand();} ll gcd(ll x,ll y){ if (!y) return x; return gcd(y,x%y); } bool Miller_Rabin(ll n){ if (n==2||n==3) return true; if (!(n&amp;1)||(n==1)||!(n%3)) return false; ll p=n-1,m=0; while (!(p&amp;1)) p&gt;&gt;=1,++m; int Case=8; while (Case--){ ll lst=qpow(rdm()%(n-1)+1,p,n),now=lst; for (int i=1;i&lt;=m;i++){ now=mul(now,now,n); if (now==1&amp;&amp;lst!=1&amp;&amp;lst!=n-1) return false; lst=now; } if (now!=1) return false; } return true; } ll Pollard_Rho(ll n,int c){ ll i=1,k=2,x=rand()%(n-1)+1,y=x,sum=1; while (true){ i++; x=(mul(x,x,n)+c)%n; sum=mul(sum,(y-x+n)%n,n); if (x==y||!sum) return n; if (i==k||i%127==0){ int d=gcd(sum,n); if (d!=1) return d; if (i==k){ y=x; k&lt;&lt;=1;} } } } void work(ll n){ if (n&lt;=ans) return; if (Miller_Rabin(n)){ ans=max(ans,n); return; } ll tmp=n; while (tmp==n) tmp=Pollard_Rho(n,rand()%n); while (n%tmp==0) n/=tmp; work(tmp); work(n); } int main(){ srand(time(NULL)); int T; ll x; scanf(&quot;%d&quot;,&amp;T); while (T--){ scanf(&quot;%lld&quot;,&amp;x); if (Miller_Rabin(x)){ puts(&quot;Prime&quot;); continue;} ans=0; work(x); printf(&quot;%lld\\n&quot;,ans); } return 0; } //贴个超级短的： LL pollardRho(LL n, int a){ LL x=2,y=2,d=1; while(d==1){ x=(x*x+a)%n; y=(y*y+a)%n;y=(y*y+a)%n; d=gcd(abs(x-y),n); } if(d==n) return pollardRho(n,a+1); return d; } 1.7 欧拉筛（线性筛）最小质因子 //注意1不为质数 for (int i=2;i&lt;=n;i++){ if (!lst[i]){ lst[i]=i; prime[++cnt]=i; } for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++){ lst[i*prime[j]]=prime[j]; if (i%prime[j]==0) break; } } 1.8 BSGS int BSGS(ll a,ll b){ int blo=(int)(sqrt(p)+1); ll base=b; for(int i=0;i&lt;blo;i++){ myhash[base]=i; base=base*a%Mod; } ll tmp=1; base=qpow(a,blo); for(int i=1;i&lt;=blo+1;i++){ tmp=tmp*base%Mod; int t=tmp; if (myhash.count(t)) return i*blo-myhash[t]; } return -1; } 1.9 欧拉筛（线性筛）mu/phi int cnt,mu[110000],p[110000],phi[110000]; bool vis[110000]; void init(int n){ vis[1]=1;//注意，1不是质数 phi[1]=0; mu[1]=1; for (int i=2;i&lt;=n;i++){ if (!vis[i]){ p[++cnt]=i; phi[i]=i-1; mu[i]=-1; } for (int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;j++){ vis[i*p[j]]=true; if (i%p[j]==0){ phi[i*p[j]]=phi[i]*p[j]; mu[i*p[j]]=0; break; } phi[i*p[j]]=phi[i]*(p[j]-1); mu[i*p[j]]=-mu[i]; } } } 1.10 求原根 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int p,phi; int gcd(int a,int b){ if (!b) return a; return gcd(b,a%b); } ll qpow(ll x,ll a,ll Mod){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } int cnt,fac[110000]; void getfac(int x){ for (int i=2;i*i&lt;=x;i++) if (x%i==0){ fac[++cnt]=i; while (x%i==0)x/=i; } if (x!=1) fac[++cnt]=x; } int primitive_root(){ getfac(phi); for (int i=1;i&lt;p;i++){ if (gcd(i,p)!=1) continue; int flag=true; for (int j=1;j&lt;=cnt;j++) if (qpow(i,phi/fac[j],p)==1){ flag=false; break; } if (flag) return i; } return -1; } int getphi(int x){ int ans=x; for (int i=2;i*i&lt;=x;i++) if (x%i==0){ ans=1ll*ans*(i-1)/i; while (x%i==0) x/=i; } if (x&gt;1) ans=1ll*ans*(x-1)/x; return ans; } int main(){ scanf(&quot;%d&quot;,&amp;p); phi=getphi(p); int g=primitive_root(); printf(&quot;%d\\n&quot;,g); return 0; } 2.数据结构 2.1 树状数组 单点加，区间求和 void add(int *tree,int x,int y){ for (;x&lt;=N;x+=x&amp;-x) tree[x]+=y; } int getsum(int *tree,int x){ int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum; } 区间加，区间求和 /* b[i]=a[i]-a[i-1] a[1] + a[2] + ... + a[n] = (b[1]) + (b[1]+b[2]) + ... + (b[1]+b[2]+...+b[n]) = n*b[1] + (n-1)*b[2] +... +b[n] = n * (b[1]+b[2]+...+b[n]) - (0*b[1]+1*b[2]+...+(n-1)*b[n]) sum1[i] = \\sum b[i],sum2[i] = \\sum b[i]*(i-1) */ int n,a[N]; int sum1[N],sum2[N]; void change(int x,int y){ for (int i=x;i&lt;=n;i+=(i&amp;-i)){ sum1[i]+=y; sum2[i]+=y*(x-1); } } void range_change(int l,int r,int y){ change(l,y); change(r+1,-y); } int query(int x){ int res=0; for (int i=x;i&gt;=1;i-=(i&amp;-i)) res+=x*sum1[i]-sum2[i]; return res; } int range_query(int l,int r){ return query(r)-query(l-1);} int main(){ for (int i=1;i&lt;=n;i++) change(i,a[i]-a[i-1]); //[l,r] +x range_change(l,r,x); //sum(l,r) range_query(l,r) return 0; } 2.2 线段树（ 区间加，区间求和） #include&lt;cstdio&gt; #define ls ((now)&lt;&lt;1)//左儿子 #define rs ((now)&lt;&lt;1|1)//右儿子 using namespace std; const int MAXN=110000; typedef long long ll; int n,m; ll a[MAXN];//n-&gt;区间长度，m-&gt;询问个数，a-&gt;区间初始值 struct node{ ll val,add;//线段树的值，加法标记 } tree[MAXN&lt;&lt;2]; void pushup(int now){//上传标记 tree[now].val=tree[ls].val+tree[rs].val; } void pushdown(int now,int l,int r){//下传标记 int mid=(l+r)&gt;&gt;1; //更新实际值 tree[ls].val+=tree[now].add*(mid-l+1); tree[rs].val+=tree[now].add*(r-mid); //下传加法标记 tree[ls].add+=tree[now].add; tree[rs].add+=tree[now].add; //清空当前标记 tree[now].add=0; } void buildtree(int now,int l,int r){//建树 //零标记 tree[now].add=0; if (l==r){ tree[now].val=a[l];//初始化 return; } int mid=(l+r)&gt;&gt;1; buildtree(ls,l,mid); buildtree(rs,mid+1,r);//建子树 pushup(now);//上传更新 } void change(int now,int l,int r,int x,int y,ll k){ if (l&gt;r||x&gt;y) return; if (l==x&amp;&amp;r==y){ tree[now].add+=k;//更新加法标记 tree[now].val+=k*(r-l+1);//更新值 return; } int mid=(l+r)&gt;&gt;1; pushdown(now,l,r);//先下传 if (y&lt;=mid) change(ls,l,mid,x,y,k);//更新左子树 else if (x&gt;mid) change(rs,mid+1,r,x,y,k);//更新右子树 else change(ls,l,mid,x,mid,k),change(rs,mid+1,r,mid+1,y,k);//更新左右子树 pushup(now);//上传标记 } ll query(int now,int l,int r,int x,int y){ if (l&gt;r||x&gt;y) return 0; if (l==x&amp;&amp;r==y) return tree[now].val;//返回实际值 int mid=(l+r)&gt;&gt;1; pushdown(now,l,r);//先下传 if (y&lt;=mid) return query(ls,l,mid,x,y);//询问左子树 else if (x&gt;mid) return query(rs,mid+1,r,x,y);//询问右子树 else return query(ls,l,mid,x,mid)+query(rs,mid+1,r,mid+1,y);//将左右子树的询问答案相加 pushup(now);//上传标记 } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);//读入初始值 int op,x,y; ll k; buildtree(1,1,n);//建树 while (m--){ scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y); if (op==1){//1代表加 scanf(&quot;%lld&quot;,&amp;k); change(1,1,n,x,y,k); } else printf(&quot;%lld\\n&quot;,query(1,1,n,x,y));//其它数代表询问 } return 0; } 2.3 splay #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; const int INF=1e9; int n,m,op,x,a[110000]; int root,sz,tag[110000],ch[110000][2],f[110000],cnt[110000],key[110000],size[110000]; inline void clear(int x){ ch[x][0]=ch[x][1]=f[x]=cnt[x]=key[x]=size[x]=0; } inline int get(int x){ return ch[f[x]][1]==x; } inline void update(int x){ if (x){ size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; } } inline void pushdown(int x){ if (x&amp;&amp;tag[x]){ tag[ch[x][0]]^=1; tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]); tag[x]=0; } } inline void rotate(int x){ pushdown(f[x]); pushdown(x); int fa=f[x],gfa=f[fa],dir=get(x); ch[fa][dir]=ch[x][dir^1]; f[ch[fa][dir]]=fa; f[fa]=x; ch[x][dir^1]=fa; f[x]=gfa; if (gfa) ch[gfa][ch[gfa][1]==fa]=x; update(fa); update(x); } void splay(int x,int goal=0){ for (int fa;(fa=f[x])!=goal;rotate(x)) if (f[fa]!=goal) rotate((get(x)==get(fa))?fa:x); if (!goal) root=x; } inline int build(int l,int r,int fa){ if (l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=++sz; key[now]=a[mid]; f[now]=fa; cnt[now]=1; tag[now]=0; ch[now][0]=build(l,mid-1,now); ch[now][1]=build(mid+1,r,now); update(now); return now; } inline void insert(int v){ if (!root){ root=++sz; ch[sz][0]=ch[sz][1]=f[sz]=0; key[sz]=v; cnt[sz]=size[sz]=1; return; } int now=root,fa=0; while (true){ if (key[now]==v){ cnt[now]++; update(now); update(fa); splay(now); break; } fa=now; now=ch[now][key[now]&lt;v]; if (!now){ sz++; ch[sz][0]=ch[sz][1]=0; key[sz]=v; size[sz]=1; cnt[sz]=1; f[sz]=fa; ch[fa][key[fa]&lt;v]=sz; update(fa); splay(sz); break; } } } inline int Rank(int v){ int ans=0,now=root; while (true){ if (v&lt;key[now]) now=ch[now][0]; else{ ans+=(ch[now][0]?size[ch[now][0]]:0); if (v==key[now]){ splay(now); return ans+1; } ans+=cnt[now]; now=ch[now][1]; } } } inline int find(int x){ int now=root; while (true){ pushdown(now); if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else{ int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return now;//key[now]; x-=temp; now=ch[now][1]; } } } inline int pre(){ int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now; } inline int next(){ int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now; } inline void del(int x){ Rank(x); if (cnt[root]&gt;1){ cnt[root]--; update(root); return; } if (!ch[root][0]&amp;&amp;!ch[root][1]){ clear(root); root=0; return; } if (!ch[root][0]){ int oldroot=root; root=ch[root][1]; f[root]=0; clear(oldroot); return; } else if (!ch[root][1]){ int oldroot=root; root=ch[root][0]; f[root]=0; clear(oldroot); return; } int leftbig=pre(),oldroot=root; splay(leftbig); f[ch[oldroot][1]]=root; ch[root][1]=ch[oldroot][1]; clear(oldroot); update(root); return; } inline void print(int now){ pushdown(now); if (ch[now][0]) print(ch[now][0]); if (key[now]!=-INF&amp;&amp;key[now]!=INF) printf(&quot;%d &quot;,key[now]); if (ch[now][1]) print(ch[now][1]); } void reverse(int x,int y){//翻转[x,y] int a=find(x); int b=find(y+2); splay(a); splay(b,a); tag[ch[ch[root][1]][0]]^=1; } int main(){ scanf(&quot;%d&quot;,&amp;n); insert(-INF); insert(INF); for (int i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;op,&amp;x); switch (op){ case 1: insert(x); break; case 2: del(x); break; case 3: printf(&quot;%d\\n&quot;,Rank(x)-1); break; case 4: printf(&quot;%d\\n&quot;,key[find(x+1)]); break; case 5: insert(x); printf(&quot;%d\\n&quot;,key[pre()]); del(x); break; case 6: insert(x); printf(&quot;%d\\n&quot;,key[next()]); del(x); break; } } return 0; } 2.4 左偏树 struct pq{ int v[110000]; int l[110000],r[110000],d[110000]; int merge(int x,int y){ if (!x||!y) return x|y; if (v[x]&lt;v[y]) swap(x,y); r[x]=merge(r[x],y); if (d[r[x]]&gt;d[l[x]]) swap(l[x],r[x]); d[x]=d[r[x]]+1; return x; } void pop(int &amp;x){ x=merge(l[x],r[x]);} int top(int x){ return v[x];} } que; 2.5 LCT（Link-Cut Tree） 这部分代码敲了好几遍了，易错点 把fa[x]和f[x]混起来写。。。 access中加注释的地方写成nroot(x)。 link的时候写成f[y]=x。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ls c[x][0] #define rs c[x][1] using namespace std; int n,m,type,x,y,f[310000],c[310000][2],v[310000],s[310000],st[310000]; bool r[310000]; inline bool nroot(int x){ return x==c[f[x]][0]||x==c[f[x]][1]; } inline void pushup(int x){ s[x]=s[ls]^s[rs]^v[x]; } inline void pushr(int x){ swap(ls,rs); r[x]^=1; } inline void pushdown(int x){ if (r[x]){ if (ls) pushr(ls); if (rs) pushr(rs); r[x]=0; } } inline int dir(int x){ return c[f[x]][1]==x;} void rotate(int x){ int y=f[x],z=f[y],k=dir(x),w=c[x][!k]; if (nroot(y)) c[z][dir(y)]=x; c[x][!k]=y; c[y][k]=w; if (w) f[w]=y; f[y]=x; f[x]=z; pushup(y); } void splay(int x){ int y=x,z=0; st[++z]=y; while (nroot(y)) st[++z]=y=f[y]; while (z) pushdown(st[z--]); while (nroot(x)){ y=f[x]; if (nroot(y)) rotate(dir(x)!=dir(y)?x:y); rotate(x); } pushup(x); } void access(int x){ for (int y=0;x;y=x,x=f[y]){//注意此处，x是打通到整棵树的根的路径，所以是;x;而不是;nroot(x);。 splay(x); rs=y; pushup(x); } } inline void makeroot(int x){ access(x); splay(x); pushr(x);} int findroot(int x){ access(x); splay(x); while (ls){ pushdown(x); x=ls; } splay(x); return x; } inline void split(int x,int y){ makeroot(x); access(y); splay(y);} void link(int x,int y){ makeroot(x); if (findroot(y)!=x) f[x]=y; } void cut(int x,int y){ makeroot(x); if (findroot(y)==x&amp;&amp;f[y]==x&amp;&amp;!c[y][0]){ f[y]=0; c[x][1]=0; pushup(x); } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]); while (m--){ scanf(&quot;%d%d%d&quot;,&amp;type,&amp;x,&amp;y); switch (type){ case 0: split(x,y); printf(&quot;%d\\n&quot;,s[y]); break; case 1: link(x,y); break; case 2: cut(x,y); break; case 3: splay(x); v[x]=y; break; } } return 0; } 新写的板子 #include&lt;bits/stdc++.h&gt; int n,q,u[110000],v[110000]; template &lt;typename T&gt; class LCT{ struct node{ node *ch[2],*fa,*pathfa; T val,sum,max; bool rev; node(T v=0){ rev=false; val=sum=max=v; ch[0]=ch[1]=fa=pathfa=NULL;} bool dir(){ return this==fa-&gt;ch[1];} void pushup(){ sum=val; if (ch[0]!=NULL) sum+=ch[0]-&gt;sum; if (ch[1]!=NULL) sum+=ch[1]-&gt;sum; max=val; if (ch[0]!=NULL) max=std::max(max,ch[0]-&gt;max); if (ch[1]!=NULL) max=std::max(max,ch[1]-&gt;max); } void pushdown(){ if (rev){ std::swap(ch[0],ch[1]); if (ch[0]!=NULL) ch[0]-&gt;rev^=1; if (ch[1]!=NULL) ch[1]-&gt;rev^=1; rev=false; } } void rotate(){ node *y=fa,*z=fa-&gt;fa; if (z!=NULL) z-&gt;pushdown(); y-&gt;pushdown(); pushdown(); std::swap(pathfa,y-&gt;pathfa);//!!!!!! int k=dir(); if (z!=NULL) z-&gt;ch[y-&gt;dir()]=this; fa=z; y-&gt;ch[k]=ch[k^1]; if (ch[k^1]) ch[k^1]-&gt;fa=y; ch[k^1]=y; y-&gt;fa=this; y-&gt;pushup(); pushup(); } void splay(){ while (fa!=NULL){ if (fa-&gt;fa!=NULL){ fa-&gt;fa-&gt;pushdown(); fa-&gt;pushdown(); if (dir()==fa-&gt;dir()) fa-&gt;rotate(); else rotate(); } rotate(); } } void expose(){//使当前点是重链上最下面一个点 splay(); pushdown(); if (ch[1]){ ch[1]-&gt;fa=NULL; ch[1]-&gt;pathfa=this; ch[1]=NULL; pushup(); } } bool splice(){//将当前这条路径和上面一条路径拼起来 splay(); if (pathfa==NULL) return false; pathfa-&gt;expose(); pathfa-&gt;ch[1]=this; fa=pathfa; pathfa=NULL; fa-&gt;pushup(); return true; } void access(){//将这个点到根的路径存到一个splay中 expose(); while (splice()); } void evert(){//把一个点作为整棵树的根 access(); splay(); rev^=1; } node* findroot(){ access(); splay(); node *x=this; x-&gt;pushdown(); while (x-&gt;ch[0]) x=x-&gt;ch[0],x-&gt;pushdown(); x-&gt;splay(); return x; } T querymax(){ access(); splay(); return max; } T querysum(){ access(); splay(); return sum; } } *p[110000]; public: void evert(int u,T k){ p[u]=new node(k); } bool link(int u,int v){ p[v]-&gt;evert(); if (p[u]-&gt;findroot()==p[v]) return false; p[v]-&gt;pathfa=p[u]; return true; } bool cut(int u,int v){ p[u]-&gt;evert(); p[v]-&gt;access(); p[v]-&gt;splay(); // p[v].pushdown();???? if (p[v]-&gt;ch[0]!=p[u]) return false; p[v]-&gt;ch[0]-&gt;fa=NULL; p[v]-&gt;ch[0]=NULL; p[v]-&gt;pushup(); return true; } T querymax(int u,int v){ p[u]-&gt;evert(); return p[v]-&gt;querymax(); } T querysum(int u,int v){ p[u]-&gt;evert(); return p[v]-&gt;querysum(); } void change(int u,T k){ p[u]-&gt;splay(); p[u]-&gt;val=k; p[u]-&gt;pushup(); } }; LCT&lt;int&gt; tree; int main(){ scanf(&quot;%d&quot;,&amp;n); int x; for (int i=1;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;u[i],&amp;v[i]); for (int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x); tree.evert(i,x); } for (int i=1;i&lt;n;i++) tree.link(u[i],v[i]); scanf(&quot;%d&quot;,&amp;q); char op[11]; int u,v; while (q--){ scanf(&quot;%s%d%d&quot;,op,&amp;u,&amp;v); if (op[0]=='C') tree.change(u,v); else if (op[1]=='S') printf(&quot;%d\\n&quot;,tree.querysum(u,v)); else if (op[1]=='M') printf(&quot;%d\\n&quot;,tree.querymax(u,v)); } return 0; } 2.6 虚树 现在改为luogu2495的某篇题解 #include&lt;bits/stdc++.h&gt; using namespace std; #define il inline #define re register #define debug printf(&quot;Now is Line : %d\\n&quot;,__LINE__) #define file(a) freopen(#a&quot;.in&quot;,&quot;r&quot;,stdin);freopen(#a&quot;.out&quot;,&quot;w&quot;,stdout) #define int long long #define inf 123456789000000000 #define mod 1000000007 il int read() { re int x = 0, f = 1; re char c = getchar(); while(c &lt; '0' || c &gt; '9') { if(c == '-') f = -1; c = getchar();} while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - 48, c = getchar(); return x * f; } #define maxn 250005 struct edge { int v, w, next; }e[maxn &lt;&lt; 1]; int n, m, head[maxn], cnt, is[maxn], mi[maxn], dfn[maxn], col, t; int size[maxn], fa[maxn], top[maxn], son[maxn], dep[maxn], s[maxn]; vector&lt;int&gt;v[maxn]; il void add(int u, int v, int w) { e[++ cnt] = (edge){v, w, head[u]}; head[u] = cnt; } il bool cmp(int a, int b){return dfn[a] &lt; dfn[b];} il void dfs1(int u, int fr) { size[u] = 1, fa[u] = fr, dep[u] = dep[fr] + 1; for(re int i = head[u]; i; i = e[i].next) { int v = e[i].v; if(v == fr) continue; mi[v] = min(mi[u], e[i].w); dfs1(v, u), size[u] += size[v]; if(size[son[u]] &lt; size[v]) son[u] = v; } } il void dfs2(int u, int fr) { top[u] = fr, dfn[u] = ++ col; if(!son[u]) return; dfs2(son[u], fr); for(re int i = head[u]; i; i = e[i].next) { int v = e[i].v; if(v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); } } il int lca(int a, int b) { while(top[a] != top[b]) dep[top[a]] &gt; dep[top[b]] ? a = fa[top[a]] : b = fa[top[b]]; return dep[a] &lt; dep[b] ? a : b; } il void push(int x) { if(t == 1) {s[++ t] = x;return;} int l = lca(x, s[t]); if(l == s[t]) return; while(t &gt; 1 &amp;&amp; dfn[s[t - 1]] &gt;= dfn[l]) v[s[t - 1]].push_back(s[t]), --t; if(s[t] != l) v[l].push_back(s[t]), s[t] = l; s[++ t] = x; } il int dp(int u) { if(v[u].size() == 0) return mi[u]; int temp = 0; for(re int i = 0; i &lt; v[u].size(); ++ i) temp += dp(v[u][i]); v[u].clear(); return min(mi[u], temp); } signed main() { file(a); n = read(); for(re int i = 1; i &lt; n; ++ i) { int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); } mi[1] = inf, dfs1(1, 0), dfs2(1, 1); int T = read(); while(T --) { m = read(); for(re int i = 1; i &lt;= m; ++ i) is[i] = read(); sort(is + 1, is + m + 1, cmp); s[t = 1] = 1; for(re int i = 1; i &lt;= m; ++ i) push(is[i]); while(t &gt; 0) v[s[t - 1]].push_back(s[t]), --t; printf(&quot;%lld\\n&quot;, dp(1)); } return 0; } 3.网络流&amp;图论 3.1 最大流 dinic（建议） #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF=0x3f3f3f3f; int n,m,s,t,vis[11000],dep[11000]; ll maxflow; int edgenum=1,F[210000],V[210000],Next[210000],Head[11000],cur[11000]; void addedge(int u,int v,int f){ V[++edgenum]=v; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum; } void Add(int u,int v,int f){ addedge(u,v,f); addedge(v,u,0); } bool bfs(){ for (int i=1;i&lt;=n;i++) vis[i]=false,dep[i]=INF; dep[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty()){ int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e]){ int v=V[e]; if (dep[v]&gt;dep[u]+1&amp;&amp;F[e]){ dep[v]=dep[u]+1; if (!vis[v]){ que.push(v); vis[v]=true; } } } } return dep[t]!=INF; } int dfs(int u,int flow){ if (u==t){ maxflow+=flow; return flow; } int used=0; for (int &amp;e=cur[u];e;e=Next[e]){ int v=V[e]; if (F[e]&amp;&amp;dep[v]==dep[u]+1){ int minflow=dfs(v,min(flow-used,F[e])); F[e]-=minflow; F[e^1]+=minflow; used+=minflow; if (used==flow) break; } } return used; } int dinic(){ while (bfs()){ for (int i=1;i&lt;=n;i++) cur[i]=Head[i]; while (dfs(s,INF)); } return maxflow; } int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); int u,v,f; for (int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;f); Add(u,v,f); } dinic(); printf(&quot;%lld\\n&quot;,maxflow); return 0; } ISAP #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int INF=0x3f3f3f3f; int n,m,s,t,gap[11000],cur[11000],d[11000],que[11000]; int edgenum,vet[210000],val[210000],Next[210000],Head[11000]; void addedge(int u,int v,int cost){ vet[++edgenum]=v; val[edgenum]=cost; Next[edgenum]=Head[u]; Head[u]=edgenum; } void bfs(){ memset(gap,0,sizeof(gap)); memset(d,0,sizeof(d)); d[t]=1; gap[1]++; int head=1,tail=1; que[1]=t; while (head&lt;=tail){ int u=que[head++]; for (int e=Head[u];e;e=Next[e]) if (!d[vet[e]]){ d[vet[e]]=d[u]+1; gap[d[vet[e]]]++; que[++tail]=vet[e]; } } } int dfs(int u,int flow){ if (u==t) return flow; int used=0; for (int &amp;e=cur[u];e;e=Next[e]) if (d[u]==d[vet[e]]+1){ int tmp=dfs(vet[e],min(flow,val[e])); used+=tmp; flow-=tmp; val[e]-=tmp; val[e^1]+=tmp; if (!flow) return used; } if (!(--gap[d[u]])) d[s]=n+1; d[u]++; gap[d[u]]++; cur[u]=Head[u]; return used; } int maxflow(){ bfs(); for (int i=1;i&lt;=n;i++) cur[i]=Head[i]; int ans=dfs(s,INF); while (d[s]&lt;=n) ans+=dfs(s,INF); return ans; } int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); int u,v,cost; edgenum=1; for (int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;cost); addedge(u,v,cost); addedge(v,u,0); } printf(&quot;%d\\n&quot;,maxflow()); return 0; } 3.2 最小费用最大流 EK+SPFA（建议） #include&lt;bits/stdc++.h&gt; using namespace std; const int INF=0x3f3f3f3f; int n,m,s,t,ans,maxflow; int vis[5100],dis[5100],lst[5100]; int edgenum=1,F[110000],V[110000],Next[110000],W[110000],Head[5100],cur[5100]; void addedge(int u,int v,int f,int w){ V[++edgenum]=v; W[edgenum]=w; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum; } void Add(int u,int v,int f,int w){ addedge(u,v,f,w); addedge(v,u,0,-w); } bool spfa(){ for (int i=1;i&lt;=n;i++) vis[i]=false,dis[i]=INF; dis[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty()){ int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e]){ int v=V[e]; if (dis[v]&gt;dis[u]+W[e]&amp;&amp;F[e]){ dis[v]=dis[u]+W[e]; lst[v]=e; if (!vis[v]){ que.push(v); vis[v]=true; } } } } return dis[t]!=INF; } int mincostmaxflow(){ while (spfa()){ int tmp=INF; for (int i=t;i!=s;i=V[lst[i]^1]) tmp=min(tmp,F[lst[i]]); for (int i=t;i!=s;i=V[lst[i]^1]) F[lst[i]]-=tmp,F[lst[i]^1]+=tmp; ans+=dis[t]*tmp; maxflow+=tmp; } return maxflow; } int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); int u,v,f,w; for (int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;f,&amp;w); Add(u,v,f,w); } mincostmaxflow(); printf(&quot;%d %d\\n&quot;,maxflow,ans); return 0; } EK+1次SPFA+dijkstra（建议） #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; pii; const int INF=0x3f3f3f3f; int n,m,s,t,ans,maxflow; int vis[5100],dis[5100],lst[5100],h[5100]; int edgenum=1,F[110000],V[110000],Next[110000],W[110000],Head[5100],cur[5100]; void addedge(int u,int v,int f,int w){ V[++edgenum]=v; W[edgenum]=w; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum; } void Add(int u,int v,int f,int w){ addedge(u,v,f,w); addedge(v,u,0,-w); } bool dijkstra(){ for (int i=1;i&lt;=n;i++) vis[i]=false,dis[i]=INF; dis[s]=0; priority_queue&lt;pii&gt; que; que.push(pii(0,s)); while (!que.empty()){ int u=que.top().second; que.pop(); if (vis[u]) continue; vis[u]=true; for (int e=Head[u];e;e=Next[e]){ int v=V[e]; if (dis[v]&gt;dis[u]+W[e]+h[u]-h[v]&amp;&amp;F[e]){ dis[v]=dis[u]+W[e]+h[u]-h[v]; lst[v]=e; que.push(pii(-dis[v],v)); } } } return dis[t]!=INF; } bool spfa(){ for (int i=1;i&lt;=n;i++) vis[i]=false,dis[i]=INF; dis[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty()){ int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e]){ int v=V[e]; if (dis[v]&gt;dis[u]+W[e]&amp;&amp;F[e]){ dis[v]=dis[u]+W[e]; lst[v]=e; if (!vis[v]){ que.push(v); vis[v]=true; } } } } return dis[t]!=INF; } int mincostmaxflow(){ spfa(); while (dijkstra()){ int tmp=INF; for (int i=t;i!=s;i=V[lst[i]^1]) tmp=min(tmp,F[lst[i]]); for (int i=t;i!=s;i=V[lst[i]^1]) F[lst[i]]-=tmp,F[lst[i]^1]+=tmp; ans+=(h[t]-h[s]+dis[t])*tmp; maxflow+=tmp; for (int i=1;i&lt;=n;i++) h[i]+=dis[i]; } return maxflow; } int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); int u,v,f,w; for (int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;f,&amp;w); Add(u,v,f,w); } mincostmaxflow(); printf(&quot;%d %d\\n&quot;,maxflow,ans); return 0; } dinic #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int INF=0x3f3f3f3f; int n,m,s,t; int ans,maxflow; int vis[5100];//是否到达过该点 int dist[5100]; int edgenum=1,F[110000],V[110000],Next[110000],W[110000],Head[5100]; //f:最大流量（flow），w:单位费用 void addedge(int u,int v,int f,int w){ V[++edgenum]=v; W[edgenum]=w; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum; } void Add(int u,int v,int f,int w){ addedge(u,v,f,w); addedge(v,u,0,-w); } bool spfa(){ memset(vis,false,sizeof(vis)); memset(dist,0x3f,sizeof(dist)); dist[s]=0; vis[s]=true; queue&lt;int&gt; que; que.push(s); while (!que.empty()){ int u=que.front(); que.pop(); vis[u]=false; for (int e=Head[u];e;e=Next[e]){ int d=V[e]; if (dist[d]&gt;dist[u]+W[e]&amp;&amp;F[e]){ dist[d]=dist[u]+W[e]; if (!vis[d]){ que.push(d); vis[d]=true; } } } } return dist[t]&lt;INF; } int dfs(int u,int flow){ if (u==t){ vis[t]=true; maxflow+=flow; return flow; } int used=0; vis[u]=true; for (int e=Head[u];e;e=Next[e]){ int d=V[e]; if ((!vis[d]||d==t)&amp;&amp;F[e]&amp;&amp;dist[d]==dist[u]+W[e]){ int minflow=dfs(d,min(flow-used,F[e])); if (minflow!=0) ans+=W[e]*minflow,F[e]-=minflow,F[e^1]+=minflow,used+=minflow; if (used==flow) break; } } return used; } int mincostmaxflow(){ while (spfa()){ vis[t]=1; while (vis[t]){ memset(vis,false,sizeof(vis)); dfs(s,INF); } } return maxflow; } int main(){ n=read(),m=read(),s=read(),t=read(); int u,v,f,w; for (register int i=1;i&lt;=m;i++){ u=read(),v=read(),f=read(),w=read(); Add(u,v,f,w); } mincostmaxflow(); printf(&quot;%d %d\\n&quot;,maxflow,ans); return 0; } EK+dijkstra（最小费用流！！！！不是最小费用最大流！！！） /* CF164C 有n个任务，每个任务给定一个开始时间si、持续时间ti、所得收益ci； 有k台机器，每台机器一个时刻只能处理一个任务； 求如何安排，使得收益和最大。 */ #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; pii; const int INF=0x3f3f3f3f; int n,k,s,t,ans,maxflow,u[5100],v[5100],c[5100]; int cnt,num[5100],h[5100],vis[5100],dis[5100],lst[5100]; int edgenum=1,F[110000],V[110000],Next[110000],W[110000],Head[5100],cur[5100]; void addedge(int u,int v,int f,int w){ V[++edgenum]=v; W[edgenum]=w; F[edgenum]=f; Next[edgenum]=Head[u]; Head[u]=edgenum; } void Add(int u,int v,int f,int w){ if (w&lt;0){ num[u]-=f; num[v]+=f; addedge(v,u,f,-w); // cerr&lt;&lt;&quot;#&quot;&lt;&lt;v&lt;&lt;' '&lt;&lt;u&lt;&lt;' '&lt;&lt;f&lt;&lt;' '&lt;&lt;-w&lt;&lt;endl; addedge(u,v,0,w); ans+=w*f; } else{ addedge(u,v,f,w); // cerr&lt;&lt;&quot;#&quot;&lt;&lt;u&lt;&lt;' '&lt;&lt;v&lt;&lt;' '&lt;&lt;f&lt;&lt;' '&lt;&lt;w&lt;&lt;endl; addedge(v,u,0,-w); } } bool dijkstra(){ for (int i=s;i&lt;=t;i++) vis[i]=false,dis[i]=INF; dis[s]=0; priority_queue&lt;pii&gt; que; que.push(pii(0,s)); while (!que.empty()){ int u=que.top().second; que.pop(); if (vis[u]) continue; vis[u]=true; for (int e=Head[u];e;e=Next[e]){ int v=V[e]; if (dis[v]&gt;dis[u]+W[e]+h[u]-h[v]&amp;&amp;F[e]){ dis[v]=dis[u]+W[e]+h[u]-h[v]; lst[v]=e; que.push(pii(-dis[v],v)); } } } return dis[t]!=INF; } int mincostmaxflow(){ while (dijkstra()){ int tmp=INF; for (int i=t;i!=s;i=V[lst[i]^1]) tmp=min(tmp,F[lst[i]]); for (int i=t;i!=s;i=V[lst[i]^1]) F[lst[i]]-=tmp,F[lst[i]^1]+=tmp; ans+=(h[t]-h[s]+dis[t])*tmp; maxflow+=tmp; for (int i=s;i&lt;=t;i++) h[i]+=dis[i]; } return maxflow; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u[i],&amp;v[i],&amp;c[i]); v[i]+=u[i]; num[++cnt]=u[i]; num[++cnt]=v[i]; } sort(num+1,num+cnt+1); cnt=unique(num+1,num+cnt+1)-num-1; s=0; t=cnt+1; for (int i=1;i&lt;=n;i++){ u[i]=lower_bound(num+1,num+cnt+1,u[i])-num; v[i]=lower_bound(num+1,num+cnt+1,v[i])-num; } for (int i=1;i&lt;=cnt;i++) num[i]=0; num[1]+=k; num[cnt]-=k; for (int i=1;i&lt;=n;i++) Add(u[i],v[i],1,-c[i]); for (int i=1;i&lt;=cnt;i++){ if (num[i]&gt;0) Add(s,i,num[i],0); if (num[i]&lt;0) Add(i,t,-num[i],0); } for (int i=1;i&lt;cnt;i++) Add(i,i+1,k,0); mincostmaxflow(); // printf(&quot;%d\\n&quot;,-ans); for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,F[i&lt;&lt;1]); return 0; } 3.3 无向图欧拉回路 // 求出欧拉图中的一条欧拉回路 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int head[100010], ver[1000010], Next[1000010], tot; // 邻接表 int stack[1000010], ans[1000010]; // 模拟系统栈，答案栈 bool vis[1000010]; int n, m, top, t; void add(int x, int y) { ver[++tot] = y, Next[tot] = head[x], head[x] = tot; } void euler() { stack[++top] = 1; while (top &gt; 0) { int x = stack[top], i = head[x]; // 找到一条尚未访问的边 while (i &amp;&amp; vis[i]) i = Next[i]; // 沿着这条边模拟递归过程，标记该边，并更新表头 if (i) { stack[++top] = ver[i]; head[x] = Next[i]; vis[i] = vis[i ^ 1] = true; } // 与x相连的所有边均已访问，模拟回溯过程，并记录于答案栈中 else { top--; ans[++t] = x; } } } int main() { cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y), add(y, x); } euler(); for (int i = t; i; i--) printf(&quot;%d\\n&quot;, ans[i]); } 3.4 无向图Tarjan算法 注意!的部分 // tarjan算法求无向图的桥、边双连通分量并缩点 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int SIZE = 100010; int head[SIZE], ver[SIZE * 2], Next[SIZE * 2]; int dfn[SIZE], low[SIZE], c[SIZE]; int n, m, tot, num, dcc, tc; bool bridge[SIZE * 2]; int hc[SIZE], vc[SIZE * 2], nc[SIZE * 2]; void add(int x, int y) { ver[++tot] = y, Next[tot] = head[x], head[x] = tot; } void add_c(int x, int y) { vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc; } void tarjan(int x, int in_edge) { dfn[x] = low[x] = ++num; for (int i = head[x]; i; i = Next[i]) { int y = ver[i]; if (!dfn[y]) { tarjan(y, i); low[x] = min(low[x], low[y]); if (low[y] &gt; dfn[x]) bridge[i] = bridge[i ^ 1] = true; } else if (i != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]); } } void dfs(int x) { c[x] = dcc; for (int i = head[x]; i; i = Next[i]) { int y = ver[i]; if (c[y] || bridge[i]) continue; dfs(y); } } int main() { cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y), add(y, x); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, 0); for (int i = 2; i &lt; tot; i += 2) if (bridge[i]) printf(&quot;%d %d\\n&quot;, ver[i ^ 1], ver[i]); for (int i = 1; i &lt;= n; i++) if (!c[i]) { ++dcc; dfs(i); } printf(&quot;There are %d e-DCCs.\\n&quot;, dcc); for (int i = 1; i &lt;= n; i++) printf(&quot;%d belongs to DCC %d.\\n&quot;, i, c[i]); tc = 1; for (int i = 2; i &lt;= tot; i++) { int x = ver[i ^ 1], y = ver[i]; if (c[x] == c[y]) continue; add_c(c[x], c[y]); } printf(&quot;缩点之后的森林，点数 %d，边数 %d\\n&quot;, dcc, tc / 2); for (int i = 2; i &lt; tc; i += 2) printf(&quot;%d %d\\n&quot;, vc[i ^ 1], vc[i]); } // tarjan算法求无向图的割点、点双连通分量并缩点 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int SIZE = 100010; int head[SIZE], ver[SIZE * 2], Next[SIZE * 2]; int dfn[SIZE], low[SIZE], stack[SIZE], new_id[SIZE], c[SIZE]; int n, m, tot, num, root, top, cnt, tc; bool cut[SIZE]; vector&lt;int&gt; dcc[SIZE]; int hc[SIZE], vc[SIZE * 2], nc[SIZE * 2]; void add(int x, int y) { ver[++tot] = y, Next[tot] = head[x], head[x] = tot; } void add_c(int x, int y) { vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc; } void tarjan(int x) { dfn[x] = low[x] = ++num; stack[++top] = x; if (x == root &amp;&amp; head[x] == 0) { // 孤立点 !!!!!!!!!!!!!!!!!!!!!! dcc[++cnt].push_back(x); return; } int flag = 0; for (int i = head[x]; i; i = Next[i]) { int y = ver[i]; if (!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); if (low[y] &gt;= dfn[x]) { flag++; if (x != root || flag &gt; 1) cut[x] = true; cnt++; int z; do { z = stack[top--]; dcc[cnt].push_back(z); } while (z != y); dcc[cnt].push_back(x); } } else low[x] = min(low[x], dfn[y]); } } int main() { cin &gt;&gt; n &gt;&gt; m; tot = 1; for (int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x == y) continue; add(x, y), add(y, x); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) root = i, tarjan(i); for (int i = 1; i &lt;= n; i++) if (cut[i]) printf(&quot;%d &quot;, i); puts(&quot;are cut-vertexes&quot;); for (int i = 1; i &lt;= cnt; i++) { printf(&quot;v-DCC #%d:&quot;, i); for (int j = 0; j &lt; dcc[i].size(); j++) printf(&quot; %d&quot;, dcc[i][j]); puts(&quot;&quot;); } // 给每个割点一个新的编号(编号从cnt+1开始) num = cnt; for (int i = 1; i &lt;= n; i++) if (cut[i]) new_id[i] = ++num; // 建新图，从每个v-DCC到它包含的所有割点连边 tc = 1; for (int i = 1; i &lt;= cnt; i++) for (int j = 0; j &lt; dcc[i].size(); j++) { int x = dcc[i][j]; if (cut[x]) { add_c(i, new_id[x]); add_c(new_id[x], i); } else c[x] = i; // 除割点外，其它点仅属于1个v-DCC } printf(&quot;缩点之后的森林，点数 %d，边数 %d\\n&quot;, num, tc / 2); printf(&quot;编号 1~%d 的为原图的v-DCC，编号 &gt;%d 的为原图割点\\n&quot;, cnt, cnt); for (int i = 2; i &lt; tc; i += 2) printf(&quot;%d %d\\n&quot;, vc[i ^ 1], vc[i]); } 3.5 有向图Tarjan算法（强连通分量） 注意!的部分 void tarjan(int u) { int v; dfn[u]=low[u]=++idx;//每次dfs，u的次序号增加1 s.push(u);//将u入栈 ins[u]=1;//标记u在栈内 for(int i=head[u];i!=-1;i=e[i].next)//访问从u出发的边 { v=e[i].v; if(!dfn[v])//如果v没被处理过 { tarjan(v);//dfs(v) low[u]=min(low[u],low[v]);//u点能到达的最小次序号是它自己能到达点的最小次序号和连接点v能到达点的最小次序号中较小的 } else if(ins[v])low[u]=min(low[u],dfn[v]);//如果v在栈内，u点能到达的最小次序号是它自己能到达点的最小次序号和v的次序号中较小的 } if(dfn[u]==low[u])//!!!!!!!!!!!!!!!!!!!!!!!!!!!!! { Bcnt++; do { v=s.top(); s.pop(); ins[v]=0; Belong[v]=Bcnt; }while(u != v); } } 3.6 二分图匹配（匈牙利算法） bool dfs(int x) { for (int i = head[x], y; i; i = next[i]) if (!visit[y = ver[i]]) { visit[y] = 1; if (!match[y] || dfs(match[y])) { match[y]=x; return true; } } return false; } for (int i = 1; i &lt;= n; i++) { memset(visit, 0, sizeof(visit)); if (dfs(i)) ans++; } 3.7 二分图最大权匹配（KM算法） #include&lt;bits/stdc++.h&gt; using namespace std; const int INF=0x3f3f3f3f; int n,m,w[110][110],label_x[110],label_y[110],match[110],slack[110],lst[110]; bool vis[110]; int main(){ // freopen(&quot;matrix.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;matrix.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++){ scanf(&quot;%d&quot;,&amp;w[i][j]); label_x[i]=max(label_x[i],w[i][j]); } for (int u=1;u&lt;=n;u++){ memset(slack,0x3f,sizeof(slack)); memset(vis,false,sizeof(vis)); match[0]=u; int i,j; for (i=0;match[i];i=j){ vis[i]=true; int x=match[i],delta=INF; for (int y=1;y&lt;=n;y++) if (!vis[y]){ int tmp=label_x[x]+label_y[y]-w[x][y]; if (tmp&lt;slack[y]){ slack[y]=tmp; lst[y]=i; } if (delta&gt;slack[y]){ delta=slack[y]; j=y; } } for (int y=0;y&lt;=n;y++) if (vis[y]){ label_x[match[y]]-=delta; label_y[y]+=delta; } else slack[y]-=delta; } while (i) match[i]=match[lst[i]],i=lst[i]; } int ans=0; for (int i=1;i&lt;=n;i++) ans+=label_x[i]+label_y[i]; printf(&quot;%d\\n&quot;,ans); // printf(&quot;%d\\n&quot;,ans*n); // if (m) // for (int i=1;i&lt;=n;i++){ // for (int j=1;j&lt;=n;j++) // printf(&quot;%d &quot;,label_x[i]+label_y[j]); // putchar('\\n'); // } return 0; } 4. 矩阵&amp;多项式 4.1 多项式基础模板 struct poly{ vector&lt;int&gt; v; poly(){ v.clear();} inline int size(){ return v.size();} friend poly operator+(poly A,poly B){ int lenA=A.v.size()-1,lenB=B.v.size()-1; int len=max(lenA,lenB); A.v.resize(len+1); B.v.resize(len+1); poly C; C.v.resize(len+1); for (int i=0;i&lt;=len;i++) C.v[i]=add(A.v[i],B.v[i]); return C; } friend poly operator*(poly A,int v){ for (int i=0;i&lt;A.size();i++) A.v[i]=mul(A.v[i],v); return A; } friend poly operator*(const poly &amp;A,const poly &amp;B){ int len=A.v.size()+B.v.size()-2; poly C; C.v.resize(len+1); for (int i=0;i&lt;(int)A.v.size();i++) for (int j=0;j&lt;(int)B.v.size();j++) C.v[i+j]=add(C.v[i+j],mul(A.v[i],B.v[j])); return C; } friend poly operator%(poly A,const poly &amp;B){ int lenA=(int)A.v.size()-1,lenB=(int)B.v.size()-1; int inv=getinv(B.v[lenB]); if (lenA&lt;lenB) return A; for (int i=lenA;i&gt;=lenB;i--) if (A.v[i]){ int t=mul(A.v[i],inv); for (int j=i;j&gt;=i-lenB;j--) A.v[j]=dec(A.v[j],mul(t,B.v[lenB-i+j])); } A.v.resize(lenB+1); return A; } }; poly qpow(poly x,char *a,const poly &amp;M){//a为二进制数 poly res; res.v.clear(); res.v.push_back(1); for (int i=strlen(a)-1;i&gt;=0;i--){ if (a[i]=='1') res=(res*x)%M; x=(x*x)%M; } return res; } 4.2 FWT // 均类似于FFT/NTT的三重循环。 // Or卷积，正变换是大的+小的，逆变换是大的-小的。（两个数Or起来会变大）。 // And卷积，正变换是小的+大的，逆变换是小的-大的。（两个数And起来会变小）。 // Xor卷积，正变换和FFT/NTT一样，小的=(X+Y)，大的=(X-Y)。逆变换把结果都/2。 void FWT_or(int *a,int op){ for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;++k) if (op==1) a[i+j+k]=(a[j+k]+a[i+j+k])%Mod; else a[i+j+k]=(a[i+j+k]+Mod-a[j+k])%Mod; } void FWT_and(int *a,int op){ for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;++k) if (op==1) a[j+k]=(a[j+k]+a[i+j+k])%Mod; else a[j+k]=(a[j+k]+Mod-a[i+j+k])%Mod; } void FWT_xor(int *a,int op){ for (int i=1;i&lt;N;i&lt;&lt;=1) for (int p=i&lt;&lt;1,j=0;j&lt;N;j+=p) for (int k=0;k&lt;i;k++){ int X=a[j+k],Y=a[i+j+k]; a[j+k]=(X+Y)%Mod; a[i+j+k]=(X+Mod-Y)%Mod; if (op==-1){ a[j+k]=1ll*a[j+k]*inv2%Mod; a[i+j+k]=1ll*a[i+j+k]*inv2%Mod;//inv2为2的逆元 } } } 4.3 FFT 首先，重要的一点是rev[x]=(rev[x&gt;&gt;1]&gt;&gt;1)|((x&amp;1)&lt;&lt;(bit-1))。相当于把它的最后一个位置删去，然后反过来，此时所有位置都往左移了一位，那么右移一位，最后把最后一个位置的数放在最高位。 然后，将原序列x&lt;rev[x]的位置，交换x,rev[x]。（否则会交换两次，相当于没交换）。 考虑正变换 枚举mid，表示当前长度的一半。此时，ω=cos⁡2π2mid+sin2π2mid=cos⁡πmid+sinπmid\\omega=\\cos \\frac{2\\pi}{2mid}+sin\\frac{2\\pi}{2mid}=\\cos\\frac{\\pi}{mid}+sin \\frac{\\pi}{mid}ω=cos2mid2π​+sin2mid2π​=cosmidπ​+sinmidπ​。 然后枚举起始位置iii，必须是 2mid2mid2mid 的倍数。 初始时，w=1w=1w=1，然后，枚举段中的位置 jjj ，则 i+ji+ji+j 为左边段的真实位置，i+j+midi+j+midi+j+mid 是右边段的真实位置。 a[i+j]=(X+Y),a[i+j+mid]=w∗(X−Y)a[i + j] = (X + Y), a[i + j + mid] = w * (X - Y)a[i+j]=(X+Y),a[i+j+mid]=w∗(X−Y)，最后w∗=ωw*=\\omegaw∗=ω。 接着考虑逆变换，其实就是改变了ω\\omegaω，此时ω=cosπmid−isin⁡πmid\\omega=cos \\frac{\\pi}{mid}-i\\sin\\frac{\\pi}{mid}ω=cosmidπ​−isinmidπ​。最后要把每个数都/n。 #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN=1e7+10; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } const double Pi=acos(-1.0); struct complex{ double x,y; complex (double xx=0,double yy=0){ x=xx; y=yy;} } a[MAXN],b[MAXN]; complex operator+(complex a,complex b){ return complex(a.x+b.x,a.y+b.y);} complex operator-(complex a,complex b){ return complex(a.x-b.x,a.y-b.y);} complex operator*(complex a,complex b){ return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);} int N,M; int l,r[MAXN]; int len=1; void FFT(complex *A,int type){ for (int i=0;i&lt;len;i++) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ complex Wn(cos(Pi/mid),type*sin(Pi/mid)); for (int R=mid&lt;&lt;1,j=0;j&lt;len;j+=R){ complex w(1,0); for (int k=0;k&lt;mid;k++,w=w*Wn){ complex x=A[j+k],y=w*A[j+mid+k]; A[j+k]=x+y; A[j+mid+k]=x-y; } } } } int main(){ int N=read(),M=read(); for (int i=0;i&lt;=N;i++) a[i].x=read(); for (int i=0;i&lt;=M;i++) b[i].x=read(); while (len&lt;=N+M) len&lt;&lt;=1,l++; for (int i=0;i&lt;len;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); FFT(a,1); FFT(b,1); for (int i=0;i&lt;=len;i++) a[i]=a[i]*b[i]; FFT(a,-1); for (int i=0;i&lt;=N+M;i++) printf(&quot;%d &quot;,(int)(a[i].x/len+0.5)); return 0; } 4.4 NTT 正变换：改变了FFT中的ω\\omegaω，此时ω=gφ(Mod)mid∗2=gMod−1mid∗2\\omega = g ^ \\dfrac{\\varphi(Mod)}{mid * 2} = g ^ \\dfrac{Mod - 1}{mid * 2}ω=gmid∗2φ(Mod)​=gmid∗2Mod−1​。 逆变换：改变了FFT中的ω\\omegaω，此时ω=1gφ(Mod)mid∗2=1gMod−1mid∗2\\omega = \\dfrac 1{g ^ \\dfrac{\\varphi(Mod)}{mid * 2}}=\\dfrac 1{g ^ \\dfrac{Mod - 1}{mid * 2}}ω=gmid∗2φ(Mod)​1​=gmid∗2Mod−1​1​。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int g=3; const int Mod=998244353; const int MAXN=2100000;//&gt;n+m上取到2的幂次 int n,m,len,rev[MAXN]; ll a[MAXN],b[MAXN],c[MAXN]; inline ll qpow(ll x,int a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline int getinv(int x){ return qpow(x,Mod-2);} void NTT(ll *a,int inv){ for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;n;mid&lt;&lt;=1){ int tmp=qpow(g,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;n;i+=mid*2){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=omega*tmp%Mod){ int x=a[i+j],y=omega*a[i+j+mid]%Mod; a[i+j]=(x+y)%Mod,a[i+j+mid]=(x-y+Mod)%Mod; } } } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); n++; m++; for (int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for (int i=0;i&lt;m;i++) scanf(&quot;%lld&quot;,&amp;b[i]); len=n+m-1; int bit=0; while ((1&lt;&lt;bit)&lt;len) bit++; n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,1); NTT(b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(a,-1); ll inv=getinv(n); for (int i=0;i&lt;len;i++){ c[i]=a[i]*inv%Mod; printf(&quot;%lld &quot;,c[i]); } return 0; } 4.5 多项式求逆 就一个式子，将变换后的按位乘改为：b[i]=(2−c[i]∗b[i])∗b[i]b[i] = (2 - c[i] * b[i]) * b[i]b[i]=(2−c[i]∗b[i])∗b[i]。 void polymul(vec &amp;a,vec &amp;b,vec &amp;c,int bit){ int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(n,a,1); NTT(n,b,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]%Mod; NTT(n,a,-1); ll inv=getinv(n); c.resize(n); for (int i=0;i&lt;n;i++) c[i]=a[i]*inv%Mod; a.clear(); b.clear(); } void polyinv(int len,int bit,vec &amp;a,vec &amp;b){ int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); vec c=a; c.resize(len); NTT(n,c,1); NTT(n,b,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(n,b,-1); b.resize(len); ll inv=getinv(n); for (int i=0;i&lt;len;i++) b[i]=b[i]*inv%Mod; } int getbit(int x){ int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit; } void getinv(int n,vec &amp;a,vec &amp;b){ if (n==1){ b.resize(1); b[0]=getinv(a[0]); return; } getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b); } 非递归版 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int Mod=998244353; const int inv2=(Mod+1)/2; int rev[810000]; int f[810000],g[810000]; ll fac[110000],inv[110000]; ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } void NTT(int *a,int n,int op){ for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;n;mid&lt;&lt;=1){ int tmp=qpow(3,(Mod-1)/(mid&lt;&lt;1)); if (op==-1) tmp=qpow(tmp,Mod-2); for (int i=0;i&lt;n;i+=(mid&lt;&lt;1)){ ll omega=1; for (int j=0;j&lt;mid;j++,omega=omega*tmp%Mod){ int x=a[i+j],y=omega*a[i+j+mid]%Mod; a[i+j]=(x+y)%Mod; a[i+j+mid]=(x-y+Mod)%Mod; } } } if (op==1) return; ll inv=qpow(n,Mod-2); for (int i=0;i&lt;n;i++) a[i]=a[i]*inv%Mod; } void polysqr(int *a,int n){ int len; for (len=1;len&lt;(n&lt;&lt;1);len&lt;&lt;=1); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?(len&gt;&gt;1):0); NTT(a,len,1); for (int i=0;i&lt;len;i++) a[i]=1ll*a[i]*a[i]%Mod; NTT(a,len,-1); for (int i=n;i&lt;len;i++) a[i]=0; } void polyinv(int *a,int *b,int n){ static int A[810000],B[810000]; b[0]=qpow(a[0],Mod-2); for (int mid=2;mid&lt;(n&lt;&lt;1);mid&lt;&lt;=1){ int len=mid&lt;&lt;1; for (int i=0;i&lt;mid;i++) A[i]=a[i],B[i]=b[i]; for (int i=mid;i&lt;len;i++) A[i]=0,B[i]=0; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?mid:0); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) b[i]=1ll*(Mod+2-1ll*A[i]*B[i]%Mod)*B[i]%Mod; NTT(b,len,-1); for (int i=mid;i&lt;len;i++) b[i]=0; } } void polysqrt(int *a,int *b,int n){ static int A[810000],B[810000]; b[0]=qpow(a[0],Mod-2); for (int mid=2;mid&lt;(n&lt;&lt;1);mid&lt;&lt;=1){ int len=mid&lt;&lt;1; for (int i=0;i&lt;mid;i++) A[i]=a[i]; for (int i=mid;i&lt;len;i++) A[i]=0; polyinv(b,B,mid); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?mid:0); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) A[i]=1ll*A[i]*B[i]%Mod; NTT(A,len,-1); for (int i=0;i&lt;mid;i++) b[i]=1ll*(b[i]+A[i])%Mod*inv2%Mod; for (int i=mid;i&lt;len;i++) b[i]=0; } } int T,n; int main(){ fac[0]=1; for (int i=1;i&lt;=100000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=100000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; inv[0]=1; for (int i=1;i&lt;=100000;i++) inv[i]=inv[i-1]*inv[i]%Mod; for (int i=0;i&lt;=100000;i++) f[i]=qpow(qpow(3,1ll*i*(i-1)/2),Mod-2)*inv[i]%Mod; polysqr(f,100001); for (int i=0;i&lt;=100000;i++) f[i]=qpow(3,1ll*i*(i-1)/2)*f[i]%Mod; polysqrt(f,g,100001); scanf(&quot;%d&quot;,&amp;T); while (T--){ scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\\n&quot;,1ll*g[n]*fac[n]%Mod); } return 0; } 4.6 拉格朗日插值 $\\displaystyle f(x)=\\sum_{i=1}^n y_i\\prod_{i\\not= j} \\frac{x-x_j}{x_i-x_j} $ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);//求f(k) for (int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]);//f(x[i])=y[i] ll s1,s2,ans=0; for (int i=1;i&lt;=n;i++){ s1=y[i]%Mod; s2=1ll; for (int j=1;j&lt;=n;j++) if (i!=j){ s1=s1*(k-x[j])%Mod; s2=s2*(x[i]-x[j])%Mod; } s1=(s1+Mod)%Mod; s2=(s2+Mod)%Mod; ans=(ans+s1*inv(s2))%Mod; } printf(&quot;%lld\\n&quot;,ans); //1..n int Lagrange(int k){ if (k&lt;=n) return f[k]; int res=0; for (int i=1;i&lt;=n;i++){ int s=1; for (int j=0;j&lt;=n;j++){ if (i==j) continue; s=1ll*s*((k-j)%Mod+Mod)%Mod; if (i&gt;j) s=1ll*s*inv[i-j]%Mod; else s=(Mod-1ll*s*inv[j-i]%Mod)%Mod; } res=(res+1ll*f[i]*s%Mod)%Mod; } return res; } 4.7 下降幂多项式乘法 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int Mod=998244353; const int G=3; int n,m,len; ll f[610000],g[610000],s[610000]; ll fac[610000],invfac[610000]; int rev[610000]; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } char readop(){ char ch=Getchar(); while (ch&lt;'A'||ch&gt;'Z') ch=Getchar(); return ch; } ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} inline ll getinv(int x){ return qpow(x,Mod-2);} void NTT(ll *a,int inv){ for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1)){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp)){ int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); } } } if (inv==-1){ ll inv=getinv(len); for (int i=0;i&lt;n;i++) a[i]=mul(a[i],inv); } } void FDT(ll *f,int inv){ if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,1); NTT(s,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,-1); for (int i=n;i&lt;len;i++) f[i]=0; } int main(){ n=read()+1; m=read()+1; for (int i=0;i&lt;n;i++) f[i]=read(); for (int i=0;i&lt;m;i++) g[i]=read(); n=n+m-1; int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fac[0]=1; for (int i=1;i&lt;=len;i++) fac[i]=fac[i-1]*i%Mod; invfac[1]=1; for (int i=2;i&lt;=len;i++) invfac[i]=(Mod-Mod/i)*invfac[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=len;i++) invfac[i]=invfac[i-1]*invfac[i]%Mod; FDT(f,1); FDT(g,1); for (int i=0;i&lt;n;i++) f[i]=mul(mul(f[i],g[i]),fac[i]); FDT(f,-1); for (int i=0;i&lt;n;i++) printf(&quot;%lld &quot;,f[i]); return 0; } 4.8 多项式除法 A(x)/B(x)A(x)/B(x)A(x)/B(x) AAA的最高次项为 xnx^nxn，BBB 的最高次项为 xmx^mxm。 把 A,BA,BA,B 翻转，BBB 的最高此项改为 xn−mx^{n-m}xn−m。 求出 BBB 的逆，和 AAA 乘起来，再取 x0...xn−mx^0...x^{n-m}x0...xn−m。再翻转 ，输出。 #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; //#define int long long #define ls (now&lt;&lt;1) #define rs (now&lt;&lt;1|1) using namespace std; typedef long long ll; typedef vector&lt;int&gt; poly; const int Mod=998244353; const int G=3; const int invG=332748118; int n,m,a[310000],rev[310000],ans[310000]; poly f,g; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline ll getinv(int x){ return qpow(x,Mod-2);} void NTT(poly &amp;a,int len,int inv){ a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); // printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1)){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp)){ int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); } } } if (inv==-1){ ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } } void mult(poly a,poly b,poly &amp;c,int n){ int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1); } void polyinv(int len,int bit,poly &amp;a,poly &amp;b){ int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len); } int getbit(int x){ int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit; } void getinv(int n,poly &amp;a,poly &amp;b){ if (n==1){ b.resize(1); b[0]=getinv(a[0]); return; } getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b); } poly c,d; poly getdiv(poly a,poly b){ int n=a.size()-1,m=b.size()-1; if (n&lt;m){ d.resize(1); d[0]=0; return d; } reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d; } poly ans1,tmp,ans2; void getmod(poly &amp;a,poly b,poly &amp;c){ int n=a.size()-1,m=b.size()-1; if (n&lt;m) return; ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]); } int main(){ n=read(); m=read(); f.resize(n+1); g.resize(m+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=0;i&lt;=m;i++) g[i]=read(); getmod(f,g,ans2); ans1.resize(n-m); for (int i=0;i&lt;=n-m;i++) printf(&quot;%d &quot;,ans1[i]); putchar('\\n'); for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,ans2[i]); return 0; } /* 5 1 15466465 9465465 2154654 64546 4546466 8664456 1545 75468 */ 4.9 多点求值 #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #define ls (now&lt;&lt;1) #define rs (now&lt;&lt;1|1) using namespace std; typedef long long ll; typedef vector&lt;int&gt; poly; const int Mod=998244353; const int G=3; const int invG=332748118; int n,m,a[310000],rev[310000],ans[310000]; ll Inv[2100000],powG[2100000],powInvG[2100000]; poly f; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline ll getinv(const int &amp;x){ return qpow(x,Mod-2);} void NTT(poly &amp;a,const int &amp;len,const int &amp;inv){ a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ int tmp; if (inv==1) tmp=powG[mid]; else tmp=powInvG[mid]; // int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); // if (inv==-1) tmp=getinv(tmp); // printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1)){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp)){ int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); } } } if (inv==-1){ ll inv=Inv[len]; for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } } /*void NTT(poly &amp;a,int len,int inv){ a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); // printf(&quot;%d &quot;,(Mod-1)/(mid&lt;&lt;1)); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1)){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp)){ int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); } } } if (inv==-1){ ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } }*/ void mult(poly a,poly b,poly &amp;c,const int &amp;n){ int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1); } void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b){ int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len); } inline int getbit(const int &amp;x){ int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit; } void getinv(const int &amp;n,poly &amp;a,poly &amp;b){ if (n==1){ b.resize(1); b[0]=getinv(a[0]); return; } getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b); } poly c,d; poly getdiv(poly a,poly b){ int n=a.size()-1,m=b.size()-1; if (n&lt;m){ d.resize(1); d[0]=0; return d; } reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d; } poly ans1,tmp,ans2; void getmod(poly a,poly b,poly &amp;c){ while (!b.empty()&amp;&amp;!b.back()) b.pop_back(); int n=a.size()-1,m=b.size()-1; if (n&lt;m){ c=a; return;} ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]); } poly p[310000]; void getpoly(const int &amp;now,const int &amp;l,const int &amp;r){ if (l==r){ p[now].push_back(dec(0,a[l])); p[now].push_back(1); return; } int mid=(l+r)&gt;&gt;1; getpoly(ls,l,mid); getpoly(rs,mid+1,r); mult(p[ls],p[rs],p[now],r-l+2); } void solve(const poly &amp;A,const int &amp;now,const int &amp;l,const int &amp;r){ if (r-l&lt;=1000){ for (int i=l;i&lt;=r;i++){ int s=0; for (int j=A.size()-1;j&gt;=0;j--) s=add(mul(s,a[i]),A[j]); ans[i]=s; } return; } poly B; int mid=(l+r)&gt;&gt;1; getmod(A,p[ls],B); solve(B,ls,l,mid); getmod(A,p[rs],B); solve(B,rs,mid+1,r); } int main(){ for (int mid=1;mid&lt;=2000000;mid&lt;&lt;=1){ powG[mid]=qpow(G,(Mod-1)/(mid&lt;&lt;1)); powInvG[mid]=qpow(powG[mid],Mod-2); } Inv[1]=1; for (int i=2;i&lt;=2000000;i++) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod; n=read(); m=read(); f.resize(n+1); for (int i=0;i&lt;=n;i++) f[i]=read(); for (int i=1;i&lt;=m;i++) a[i]=read(); // n=64000; m=64000; f.resize(n+1); // for (int i=0;i&lt;=n;i++) f[i]=1; // for (int i=1;i&lt;=m;i++) a[i]=i; getpoly(1,1,m); getmod(f,p[1],f); solve(f,1,1,m); for (int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } 4.10 多项式ln/exp #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; typedef vector&lt;int&gt; poly; typedef long long ll; const int Mod=998244353; const int G=3; int n,m,a[310000],rev[310000],ans[310000]; poly f,g; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline ll getinv(const int &amp;x){ return qpow(x,Mod-2);} void NTT(poly &amp;a,int len,int inv){ a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ int tmp=qpow(G,(Mod-1)/(mid&lt;&lt;1)); if (inv==-1) tmp=getinv(tmp); for (int i=0;i&lt;len;i+=(mid&lt;&lt;1)){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp)){ int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); } } } if (inv==-1){ ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } } void mult(poly a,poly b,poly &amp;c,const int &amp;n){ int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1); } void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b){ int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=1ll*(Mod+2-1ll*c[i]*b[i]%Mod)%Mod*b[i]%Mod; NTT(b,n,-1); b.resize(len); } inline int getbit(const int &amp;x){ int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit; } void getinv(const int &amp;n,poly &amp;a,poly &amp;b){ if (n==1){ b.resize(1); b[0]=getinv(a[0]); return; } getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b); } void Dao(poly &amp;A,poly &amp;B,int len){ for (int i=1;i&lt;len;i++) B[i-1]=1ll*i*A[i]%Mod; B[len-1]=0; } void Jifen(poly &amp;A,poly &amp;B,int len){ for (int i=1;i&lt;len;i++) B[i]=1ll*A[i-1]*getinv(i)%Mod; B[0]=0; } poly A,B,C; void getln(poly &amp;f,poly &amp;g,int n){ f.resize(n); g.resize(n); A.resize(n); B.resize(n); Dao(f,A,n); getinv(n,f,B); mult(A,B,C,n+n); Jifen(C,g,n); } poly t; void getexp(const int &amp;n,poly &amp;a,poly &amp;b){ if (n==1){ b.resize(1); b[0]=1; return; } getexp(n&gt;&gt;1,a,b); getln(b,t,n); for (int i=0;i&lt;n;i++) t[i]=dec(a[i],t[i]); t[0]=add(1,t[0]); mult(t,b,b,n+n); t.clear(); b.resize(n); } int main(){ n=read(); f.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); for (m=1;m&lt;=n;m&lt;&lt;=1); f.resize(m); getexp(m,f,g); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,g[i]); return 0; } 4.11 普通多项式转下降幂多项式 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ls (now&lt;&lt;1) #define rs (now&lt;&lt;1|1) using namespace std; typedef long long ll; typedef vector&lt;int&gt; poly; const int Mod=998244353; const int G=3; const int invG=332748118; int n,m,a[510000],rev[510000],ans[510000]; ll Inv[1100000]; int GPow[2][19][510000]; ll fac[1100000],invfac[1100000]; poly f; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline ll getinv(const int &amp;x){ return qpow(x,Mod-2);} inline void InitG(){ for (int p=1;p&lt;=18;p++) { int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++){ GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; } } } void NTT(poly &amp;a,const int &amp;len,int inv){ if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); /*for (int mid=1;mid&lt;len;mid&lt;&lt;=1){ int tmp; if (inv==1) tmp=powG[mid]; else tmp=powInvG[mid]; for (int i=0;i&lt;len;i+=(mid&lt;&lt;1)){ ll omega=1; for (ll j=0;j&lt;mid;j++,omega=mul(omega,tmp)){ int x=a[i+j],y=mul(omega,a[i+j+mid]); a[i+j]=add(x,y),a[i+j+mid]=dec(x,y); } } }*/ for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++){ int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l){ int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) { int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); } } } if (inv!=1){ ll inv=Inv[len]; for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } } void mult(poly a,poly b,poly &amp;c,const int &amp;n){ int bit=0; while ((1&lt;&lt;bit)&lt;n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(a,len,1); NTT(b,len,1); c.resize(len); for (int i=0;i&lt;len;i++) c[i]=mul(a[i],b[i]); NTT(c,len,-1); } void polyinv(const int &amp;len,const int &amp;bit,poly &amp;a,poly &amp;b){ int n=1&lt;&lt;bit; for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); poly c=a; c.resize(len); b.resize(len); NTT(c,n,1); NTT(b,n,1); for (int i=0;i&lt;n;i++) b[i]=mul(dec(2,mul(c[i],b[i])),b[i]); NTT(b,n,-1); b.resize(len); } inline int getbit(const int &amp;x){ int bit=1; while ((1&lt;&lt;bit)&lt;x) bit++; return bit; } void getinv(const int &amp;n,poly &amp;a,poly &amp;b){ if (n==1){ b.resize(1); b[0]=getinv(a[0]); return; } getinv((n+1)&gt;&gt;1,a,b); int bit=getbit(n&lt;&lt;1); polyinv(n,bit,a,b); } poly c,d; poly getdiv(poly a,poly b){ int n=a.size()-1,m=b.size()-1; if (n&lt;m){ d.resize(1); d[0]=0; return d; } reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); b.resize(n-m+1); c.clear(); getinv(n-m+1,b,c); d.clear(); mult(c,a,d,n+(n-m+1)); d.resize(n-m+1); reverse(d.begin(),d.end()); return d; } poly ans1,tmp,ans2; void getmod(poly a,poly b,poly &amp;c){ while (!b.empty()&amp;&amp;!b.back()) b.pop_back(); int n=a.size()-1,m=b.size()-1; if (n&lt;m){ c=a; return;} ans1=getdiv(a,b); mult(ans1,b,tmp,n+m); c.resize(m); for (int i=0;i&lt;m;i++) c[i]=dec(a[i],tmp[i]); } poly p[510000]; void getpoly(const int &amp;now,const int &amp;l,const int &amp;r){ if (l==r){ p[now].push_back(dec(0,a[l])); p[now].push_back(1); return; } int mid=(l+r)&gt;&gt;1; getpoly(ls,l,mid); getpoly(rs,mid+1,r); mult(p[ls],p[rs],p[now],r-l+2); } void solve(const poly &amp;A,const int &amp;now,const int &amp;l,const int &amp;r){ if (r-l&lt;=700){ for (int i=l;i&lt;=r;i++){ int s=0; for (int j=A.size()-1;j&gt;=0;j--) s=add(mul(s,a[i]),A[j]); ans[i]=s; } return; } poly B; int mid=(l+r)&gt;&gt;1; getmod(A,p[ls],B); solve(B,ls,l,mid); getmod(A,p[rs],B); solve(B,rs,mid+1,r); } poly s; void FDT(poly &amp;f,int len,int inv){ f.resize(len); s.resize(len); if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,len,1); NTT(s,len,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,len,-1); for (int i=n;i&lt;len;i++) f[i]=0; } int main(){ Inv[1]=1; for (int i=2;i&lt;=1000000;i++) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod; InitG(); n=read(); f.resize(n); // n=100000; f.resize(n); // for (int i=0;i&lt;n;i++) f[i]=i; for (int i=0;i&lt;n;i++) f[i]=read(); m=n; for (int i=1;i&lt;=m;i++) a[i]=i-1; getpoly(1,1,m); getmod(f,p[1],f); solve(f,1,1,m); int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fac[0]=1; for (int i=1;i&lt;=len;i++) fac[i]=fac[i-1]*i%Mod; invfac[1]=1; for (int i=2;i&lt;=len;i++) invfac[i]=(Mod-Mod/i)*invfac[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=len;i++) invfac[i]=invfac[i-1]*invfac[i]%Mod; f.resize(n); for (int i=0;i&lt;n;i++) f[i]=mul(ans[i+1],invfac[i]); FDT(f,len,-1); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,f[i]); return 0; } 4.12 下降幂多项式转普通多项式 #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int G=3,invG=332748118; const int Mod=998244353; typedef long long ll; typedef vector&lt;int&gt; poly; struct node{ poly g,f; }; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline ll getinv(int x){ return qpow(x,Mod-2);} int n,GPow[2][20][1100000]; int rev[1100000]; ll fac[1100000],inv[1100000],invfac[1100000]; poly f,tmp,ans; inline void InitG(){ fac[0]=1; for (int i=1;i&lt;=1000000;i++) fac[i]=fac[i-1]*i%Mod; inv[1]=1; for (int i=2;i&lt;=1000000;i++) inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod; invfac[0]=1; for (int i=1;i&lt;=1000000;i++) invfac[i]=invfac[i-1]*inv[i]%Mod; for (int p=1;p&lt;=19;p++) { int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++){ GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; } } } void NTT(poly &amp;a,const int &amp;len,int inv){ if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++){ int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l){ int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++){ int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); } } } if (inv!=1){ ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } } poly A,B; void mult(int n,int m,const poly &amp;a,const poly &amp;b,poly &amp;c){ n++; m++; int len=1,bit=0; while (len&lt;(n+m)) len&lt;&lt;=1,bit++; A.resize(n); B.resize(m); for (int i=0;i&lt;n;i++) A[i]=a[i]; for (int i=0;i&lt;m;i++) B[i]=b[i]; c.resize(len); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) c[i]=1ll*A[i]*B[i]%Mod; NTT(c,len,-1); } poly s; void ADD(poly &amp;a,const poly &amp;b){ if (b.size()&gt;a.size()) a.resize(b.size()); for (int i=0;i&lt;(int)b.size();i++) a[i]=add(a[i],b[i]); } void FDT(poly &amp;f,int len,int inv){ f.resize(len); s.resize(len); if (inv==1) for (int i=0;i&lt;n;i++) s[i]=invfac[i]; else for (int i=0;i&lt;n;i++) if (i&amp;1) s[i]=Mod-invfac[i]; else s[i]=invfac[i]; for (int i=n;i&lt;len;i++) s[i]=0; NTT(f,len,1); NTT(s,len,1); for (int i=0;i&lt;len;i++) f[i]=mul(f[i],s[i]); NTT(f,len,-1); f.resize(n); } node interpolation(int l,int r,const poly &amp;A,const poly &amp;B){ if (l==r){ node tmp; tmp.g.clear(); tmp.f.clear(); tmp.g.push_back(dec(0,l)); tmp.g.push_back(1); tmp.f.push_back(mul(A[l],B[l])); return tmp; } int mid=(l+r)&gt;&gt;1; node a=interpolation(l,mid,A,B); node b=interpolation(mid+1,r,A,B); poly c; mult(mid-l+1,r-mid,a.g,b.g,c); poly d; mult(mid-l+1,r-mid-1,a.g,b.f,d); poly e; mult(mid-l,r-mid,a.f,b.g,e); ADD(d,e); return (node){c,d}; } int main(){ InitG(); n=read(); f.resize(n); tmp.resize(n); for (int i=0;i&lt;n;i++) f[i]=read(); int bit=0; while ((1&lt;&lt;bit)&lt;n+n) bit++; int len=1&lt;&lt;bit; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1));f.resize(n); tmp.resize(n); FDT(f,len,1); for (int i=0;i&lt;n;i++) f[i]=mul(f[i],fac[i]); for (int i=0;i&lt;n;i++) tmp[i]=mul(invfac[i],((n-i)&amp;1)?invfac[n-i-1]:Mod-invfac[n-i-1]); ans=interpolation(0,n-1,f,tmp).f; ans.resize(n); for (int i=0;i&lt;n;i++) printf(&quot;%d &quot;,ans[i]); return 0; } 4.13 常系数齐次线性递推 #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; const int G=3,invG=332748118; const int Mod=998244353; typedef long long ll; typedef vector&lt;int&gt; poly; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } inline int add(int x,int y){return x+y&gt;=Mod?x+y-Mod:x+y;} inline int dec(int x,int y){return x-y&lt;0?x-y+Mod:x-y;} inline int mul(int x,int y){return 1ll*x*y%Mod;} ll qpow(ll x,ll a){ ll res=1; while (a){ if (a&amp;1) res=res*x%Mod; x=x*x%Mod; a&gt;&gt;=1; } return res; } inline ll getinv(int x){ return qpow(x,Mod-2);} int GPow[2][19][410000]; int rev[410000],f[410000],g[410000]; poly A,B,c,a,b; inline void InitG(){ for (int p=1;p&lt;=18;p++) { int buf1=qpow(G,(Mod-1)/(1&lt;&lt;p)); int buf0=qpow(invG,(Mod-1)/(1&lt;&lt;p)); GPow[1][p][0]=GPow[0][p][0]=1; for (int i=1;i&lt;(1&lt;&lt;p);i++){ GPow[1][p][i]=1LL*GPow[1][p][i-1]*buf1%Mod; GPow[0][p][i]=1LL*GPow[0][p][i-1]*buf0%Mod; } } } void NTT(poly &amp;a,const int &amp;len,int inv){ if (inv==-1) inv=0; a.resize(len); for (int i=0;i&lt;len;i++) if (i&lt;rev[i]) swap(a[i],a[rev[i]]); for (int l=2,cnt=1;l&lt;=len;l&lt;&lt;=1,cnt++){ int m=l&gt;&gt;1; for (int i=0;i&lt;len;i+=l){ int *buf=GPow[inv][cnt]; for (int j=0;j&lt;m;j++,buf++) { int x=a[i+j],y=1LL*(*buf)*a[i+j+m]%Mod; a[i+j]=add(x,y),a[i+j+m]=dec(x,y); } } } if (inv!=1){ ll inv=getinv(len); for (int i=0;i&lt;len;i++) a[i]=mul(a[i],inv); } } void mult(int n,int m,const poly &amp;a,const poly &amp;b,poly &amp;c){ int len=1,bit=0; while (len&lt;(n+m)) len&lt;&lt;=1,bit++; A.resize(n); B.resize(m); for (int i=0;i&lt;n;i++) A[i]=a[i]; for (int i=0;i&lt;m;i++) B[i]=b[i]; c.resize(len); for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(A,len,1); NTT(B,len,1); for (int i=0;i&lt;len;i++) c[i]=1ll*A[i]*B[i]%Mod; NTT(c,len,-1); } void PolyInv(int n,poly &amp;a,poly &amp;b){ if (n==1){ b.resize(1); b[0]=getinv(a[0]); return; } PolyInv((n+1)&gt;&gt;1,a,b); int len=1,bit=0; while (len&lt;(n&lt;&lt;1)) len&lt;&lt;=1,bit++; c.resize(n); for (int i=0;i&lt;n;i++) c[i]=a[i]; for (int i=0;i&lt;len;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); NTT(c,len,1); NTT(b,len,1); for (int i=0;i&lt;len;i++) b[i]=1ll*(2-1ll*c[i]*b[i]%Mod+Mod)%Mod*b[i]%Mod; NTT(b,len,-1); b.resize(n); } poly fr,gr,tmp,q,R,Q; void PolyMod(int n,int m,poly &amp;f,poly &amp;g,poly &amp;r){ fr.clear(); tmp.clear(); q.clear(); R.clear(); f.resize(n+1); fr.resize(n+1); for (int i=0;i&lt;=n;i++) fr[n-i]=f[i]; mult(n-m+1,n,gr,fr,q); q.resize(n-m+1); reverse(q.begin(),q.end()); mult(m+1,n-m+1,g,q,R); for (int i=0;i&lt;m;i++) r[i]=(f[i]-R[i]+Mod)%Mod; r.resize(m); } int n,k; poly res,x; int val[410000]; int main(){ InitG(); n=read(); k=read(); a.resize(k+1); res.resize(k+1); x.resize(k+1); for (int i=1;i&lt;=k;i++) a[k-i]=(Mod-read()%Mod)%Mod; for (int i=0;i&lt;=k-1;i++) val[i]=(read()%Mod+Mod)%Mod; a[k]=res[0]=1; x[1]=1; gr.resize(k+1); for (int i=0;i&lt;=k;i++) gr[k-i]=a[i]; PolyInv(k+1,gr,tmp); for (int i=0;i&lt;=k;i++) gr[i]=tmp[i]; while (n){ if (n&amp;1){ mult(k,k,res,x,res); PolyMod(2*k+1,k,res,a,res); } mult(k,k,x,x,x); PolyMod(2*k+1,k,x,a,x); n&gt;&gt;=1; } int ans=0; res.resize(k); for (int i=0;i&lt;k;i++) ans=(ans+1ll*res[i]*val[i])%Mod; printf(&quot;%d\\n&quot;,ans); return 0; } 5.字符串 5.1 后缀自动机（SAM） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int S=1; int z,n,cnt,sz[2100000],a[2100000],c[2100000],len[2100000]; int link[2100000],trans[2100000][27]; long long ans; char s[1100000]; inline void add(int loc){ int c=s[loc]-'a',v=z; z=++cnt; len[z]=loc; for (;v&amp;&amp;!trans[v][c];v=link[v]) trans[v][c]=z; if (!v) link[z]=S; else{ int x=trans[v][c]; if (len[v]+1==len[x]) link[z]=x; else { int y=++cnt; len[y]=len[v]+1; for (int i=0;i&lt;=26;i++) trans[y][i]=trans[x][i]; link[y]=link[x]; link[x]=y; link[z]=y; for (;trans[v][c]==x;v=link[v]) trans[v][c]=y; } } sz[z]=1; } void calc(){ for (int i=1;i&lt;=cnt;i++) c[len[i]]++; for (int i=1;i&lt;=cnt;i++) c[i]+=c[i-1]; for (int i=1;i&lt;=cnt;i++) a[c[len[i]]--]=i; for (int i=cnt;i;i--){ int u=a[i]; sz[link[u]]+=sz[u]; ans+=1ll*(len[u]-len[link[u]])*sz[u]*(n-sz[u]); } } int main(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); z=1; cnt=1; for (int i=1;i&lt;=n;i++) add(i); calc(); printf(&quot;%lld\\n&quot;,ans); return 0; } 5.2 回文自动机（PAM） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN=310000; const int Mod=1e9+7; const int inv2=5e8+4; char s[MAXN]; class Palindromic_tree{ /* 两棵树，记录长度为奇数和偶数的回文串 0为长度为偶数的根,1为长度为奇数的根 *1. 偶数根节点字符长度为0，不存在，将它看做一个不在字符集中的字符-1 *2. 奇数根节点字符长度为-1，作用相当于backspace，方便处理单字符形成的回文串 *3. 只更改了最长的满足条件回文串的个数， 最后要从1-&gt;tot，把fail,fail[fail],...都也加上，这样显然会T 所以要倒过来，从tot-&gt;1，cnt[fail]+=cnt[now]; */ private: int now,tot,s[MAXN]; int fail[MAXN],cnt[MAXN],len[MAXN],ch[MAXN][26]; inline int newnode(int x){ //新建一个节点，长度为x len[++tot]=x; return tot; } inline int getfail(int x,int r){ //从l节点开始找s[r]的fail while (s[r-len[x]-1]!=s[r]) x=fail[x]; //一直跳直到找到后缀回文 return x; } public: void build(const char *t,int n){ for (int i=1;i&lt;=n;i++) s[i]=t[i]-'a'; s[0]=-1; fail[0]=1; len[0]=0; //*1. len[1]=-1; //*2. now=0; tot=1; //当前在0号节点，用了&lt;=1的位置 int x,y; for (int i=1;i&lt;=n;i++){ x=getfail(now,i); //找到回文的位置 if (!ch[x][s[i]]){ //没转移过 y=newnode(len[x]+2); //前后都加上这个字符，长度加2 fail[y]=ch[getfail(fail[x],i)][s[i]]; //记录新的fail ch[x][s[i]]=y; } now=ch[x][s[i]]; cnt[now]++; //记录出现次数（只记录了最长的满足条件的）*3. } } ll getans(){ ll res=0; for (int i=tot;i&gt;=1;i--){ cnt[fail[i]]+=cnt[i]; res=(res+1ll*cnt[i]*(cnt[i]-1)%Mod*inv2)%Mod; } return res; } } tree; int main(){ scanf(&quot;%s&quot;,s+1); tree.build(s,strlen(s+1)); printf(&quot;%lld\\n&quot;,tree.getans()); return 0; } 5.3 后缀数组（SA） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; char s[1100000]; int y[1100000],x[1100000],c[1100000],sa[1100000],rk[1100000],height[1100000],wt[30]; int n,m; void get_SA(){ for (int i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; //c数组是桶 //x[i]是第i个元素的第一关键字 for (int i=2;i&lt;=m;++i) c[i]+=c[i-1]; //做c的前缀和，我们就可以得出每个关键字最多是在第几名 for (int i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for (int k=1;k&lt;=n;k&lt;&lt;=1){ int num=0; for (int i=n-k+1;i&lt;=n;++i) y[++num]=i; //y[i]表示第二关键字排名为i的数，第一关键字的位置 //第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (int i=1;i&lt;=n;++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; //排名为i的数 在数组中是否在第k位以后 //如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了 //所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 for (int i=1;i&lt;=m;++i) c[i]=0; //初始化c桶 for (int i=1;i&lt;=n;++i) ++c[x[i]]; //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 for (int i=2;i&lt;=m;++i) c[i]+=c[i-1];//第一关键字排名为1~i的数有多少个 for (int i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; //因为y的顺序是按照第二关键字的顺序来排的 //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 //基数排序 swap(x,y); //这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 x[sa[1]]=1;num=1; for (int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 if (num==n) break; m=num; //这里就不用那个122了，因为都有新的编号了 } for (int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,sa[i]); } void get_height(){ int k=0; for (int i=1;i&lt;=n;++i) rk[sa[i]]=i; for (int i=1;i&lt;=n;++i){ if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]-1; int j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; } putchar(10); for (int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,height[i]); } int main(){ gets(s+1); n=strlen(s+1); m=122; //因为这个题不读入n和m所以要自己设 //n表示原字符串长度，m表示字符个数，ascll('z')=122 //我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 //因为转化数字和大小写字母还得分类讨论，怪麻烦的 get_SA(); //get_height(); return 0; } 新的板子 struct SA{ void build(){ memset(f,0,sizeof(f)); for (int i=1;i&lt;=n;i++) f[s[i]-'a'+1]=1; for (int i=1;i&lt;=26;i++) f[i]+=f[i-1]; t=f[26]; for (int i=1;i&lt;=n;i++) rk[i]=f[s[i]-'a'+1]; for (int i=1;t&lt;n;i&lt;&lt;=1){ for (int j=1;j&lt;=n;j++) oldrk[j]=rk[j]; for (int j=1;j&lt;=n;j++) a[j]=j+i&lt;=n?rk[j+i]:0;//后i位的rank memset(f,0,sizeof(f)); for (int j=1;j&lt;=n;j++) f[a[j]]++; for (int j=1;j&lt;=t;j++) f[j]+=f[j-1]; for (int j=1;j&lt;=n;j++) g[f[a[j]]--]=j;//以后i位的rank为关键字的排序结果 memset(f,0,sizeof(f)); for (int j=1;j&lt;=n;j++) f[rk[j]]++; for (int j=1;j&lt;=t;j++) f[j]+=f[j-1]; for (int j=n;j&gt;=1;j--) sa[f[rk[g[j]]]--]=g[j];//以前i位rank为第一关键字，后i位rank为第二关键字的排序结果 t=0; for (int j=1;j&lt;=n;j++){ t+=oldrk[sa[j]]&gt;oldrk[sa[j-1]]||(oldrk[sa[j]]==oldrk[sa[j-1]]&amp;&amp;a[sa[j]]&gt;a[sa[j-1]]); rk[sa[j]]=t; } } for (int j=1;j&lt;=n;j++) sa[rk[j]]=j; int j=0; for (int i=1;i&lt;=n;i++){ if (rk[i]==n) j=0; else{ if (j) j--; while (s[i+j]==s[sa[rk[i]+1]+j]) j++; } h[rk[i]]=j; } for (int i=1;i&lt;=n;j++) ff[0][i]=h[i]; for (int j=1;(1&lt;&lt;j)&lt;=n;j++) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) ff[j][i]=min(ff[j-1][i],ff[i-1][i+(1&lt;&lt;(j-1))]); } int lcp(int x,int y){ x=rk[x]; y=rk[y]; if (x&gt;y) swap(x,y); int k=Log2[y-x]; return min(ff[k][x],ff[k][y-(1&lt;&lt;k)+1]); } }; 5.4 Manacher #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int p[21000000]; char s[11000000]; char t[21000000];//存添加字符后的字符串 int init(){//形成新的字符串 int len=strlen(s);//len是输入字符串的长度 t[0]='$';//处理边界，防止越界 t[1]='#'; int j=2; for (int i=0;i&lt;len;i++){ t[j++]=s[i]; t[j++]='#'; } t[j]='\\0';//处理边界，防止越界（容易忘记） return j;// 返回t的长度 } int Manacher(){//返回最长回文串 int len=init();//取得新字符串的长度， 完成向t的转换 int max_len=-1;//最长回文长度 int id; int mx=0; for (int i=1;i&lt;=len;i++){ if (i&lt;mx) p[i]=min(p[2*id-i],mx-i);//上面图片就是这里的讲解 else p[i]=1; while (t[i-p[i]]==t[i+p[i]])//不需边界判断，因为左有'$'，右有'\\0'标记； p[i]++;//mx对此回文中点的贡献已经结束，现在是正常寻找扩大半径 if (mx&lt;i+p[i]){//每走移动一个回文中点，都要和mx比较，使mx是最大，提高p[i]=min(p[2*id-i],mx-i)效率 id=i;//更新id mx=i+p[i];//更新mx } max_len=max(max_len,p[i]-1); } return max_len; } int main(){ scanf(&quot;%s&quot;,s); printf(&quot;%d&quot;,Manacher()); return 0; } 5.5 0/1可持久化trie void change(int &amp;x,int dep,int v){ tree[++cnt]=tree[x]; x=cnt; tree[x].sz++; if (dep==-1) return; bool k=v&amp;(1&lt;&lt;dep); if (k) change(tree[x].ch[1],dep-1,v); else change(tree[x].ch[0],dep-1,v); } void build(){ cnt=0; for (int i=1;i&lt;=n;i++){ rt[i]=rt[i-1]; change(rt[i],30,a[i]); } } 5.6 离线可删线性基 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;unordered_map&gt; using namespace std; int n,m,Q,ans,sz,op[2100000],x[2100000],lst[2100000],nxt[2100000]; bool vis[35]; struct node{ int x,y; bool operator&gt;(const node &amp;a) const{ return nxt[y]&gt;nxt[a.y]; } } c[35]; char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } unordered_map&lt;int,int&gt; num; void ins(node x){ for (int i=n;i&gt;=0;i--) if (x.x&amp;(1&lt;&lt;i)){ if (!vis[i]){ vis[i]=true; sz++; c[i]=x; break; } else{ if (x&gt;c[i]) swap(c[i],x); x.x^=c[i].x; } } } void del(int x){ for (int i=n;i&gt;=0;i--) if (vis[i]&amp;&amp;c[i].y==x){ vis[i]=false; sz--; break; } } int main(){ n=read(); Q=read(); m=(1&lt;&lt;n); for (int i=1;i&lt;=Q;i++){ op[i]=read(); x[i]=read(); nxt[num[x[i]]]=i; lst[i]=num[x[i]]; num[x[i]]=i; } for (int i=1;i&lt;=Q;i++) if (!nxt[i]) nxt[i]=Q+1; for (int i=1;i&lt;=Q;i++){ if (op[i]==1) ins((node){x[i],i}); else del(lst[i]); ans^=(m/(1&lt;&lt;sz)); } printf(&quot;%d\\n&quot;,ans); return 0; } 5.7 AC自动机 #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int T,n,q,a[510000],pos[510000],len[510000],l[510000]; int tot,sum[510000],fail[510000],ch[510000][27]; int head,tail,que[510000]; char st[510000],s[510000],pre[510000],suf[510000]; int ins(){ int now=0,len; len=strlen(suf); for (int i=0;i&lt;len;i++){ if (!ch[now][suf[i]-'a']) ch[now][suf[i]-'a']=++tot; now=ch[now][suf[i]-'a']; } if (!ch[now][26]) ch[now][26]=++tot; now=ch[now][26]; len=strlen(pre); for (int i=0;i&lt;len;i++){ if (!ch[now][pre[i]-'a']) ch[now][pre[i]-'a']=++tot; now=ch[now][pre[i]-'a']; } l[now]=strlen(suf)+strlen(pre); return now; } void build(){ int head=1,tail=0; for (int i=0;i&lt;=26;i++) if (ch[0][i]) que[++tail]=ch[0][i]; while (head&lt;=tail){ int now=que[head++]; for(int i=0;i&lt;=26;i++){ if (ch[now][i]){ fail[ch[now][i]]=ch[fail[now]][i]; que[++tail]=ch[now][i]; } else ch[now][i]=ch[fail[now]][i]; } } } void query(int x,int len){ int now=0; for (int i=x+1;i&lt;=x+len;i++) now=ch[now][st[i]-'a']; now=ch[now][26]; for (int i=x+1;i&lt;=x+len;i++){ now=ch[now][st[i]-'a']; int tmp=now; while (l[tmp]&gt;len) tmp=fail[tmp]; sum[tmp]++; } } int main(){ scanf(&quot;%d&quot;,&amp;T); while (T--){ memset(fail,0,sizeof(fail)); memset(sum,0,sizeof(sum)); memset(ch,0,sizeof(ch)); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); int cnt=0; tot=0; for (int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); len[i]=strlen(s+1); a[i]=cnt; for (int j=1;j&lt;=len[i];j++) st[++cnt]=s[j]; } for (int i=1;i&lt;=q;i++){ scanf(&quot;%s%s&quot;,pre,suf); pos[i]=ins(); } build(); for (int i=1;i&lt;=n;i++) query(a[i],len[i]); for (int i=tot;i&gt;=1;i--) sum[fail[que[i]]]+=sum[que[i]]; for (int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,sum[pos[i]]); } return 0; } 6.分治 6.1 整体二分 #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int MAXN=1100000; typedef long long ll; int n,m,x,k,t[MAXN],ans[MAXN]; ll tree[MAXN]; vector&lt;int&gt; vec[MAXN]; struct node{ int l,r,num; bool isq; ll k; } a[MAXN],Left[MAXN],Right[MAXN]; inline void add(int x,ll y){ for (;x&lt;=m;x+=x&amp;-x) tree[x]+=y; } inline ll getsum(int x){ ll sum=0; for (;x;x-=x&amp;-x) sum+=tree[x]; return sum; } void solve(int L,int R,int l,int r){ if (l&gt;r) return; if (L==R){ for (int i=l;i&lt;=r;i++) if (a[i].isq) ans[a[i].num]=L; return; } int mid=(L+R)&gt;&gt;1,n=0,m=0; for (int i=l;i&lt;=r;i++){ if (a[i].isq){ ll tmp=0; for (int j=0;j&lt;vec[a[i].num].size();j++){ tmp+=getsum(vec[a[i].num][j]); if (tmp&gt;=a[i].k) break; } if (tmp&gt;=a[i].k) Left[++n]=a[i]; else a[i].k-=tmp,Right[++m]=a[i]; } else{ if (a[i].num&lt;=mid){ if (a[i].l&lt;=a[i].r){ add(a[i].l,a[i].k); add(a[i].r+1,-a[i].k); } else{ add(1,a[i].k); add(a[i].r+1,-a[i].k); add(a[i].l,a[i].k); } Left[++n]=a[i]; } else Right[++m]=a[i]; } } for (int i=l;i&lt;=r;i++) if (a[i].num&lt;=mid&amp;&amp;!a[i].isq){ if (a[i].l&lt;=a[i].r){ add(a[i].l,-a[i].k); add(a[i].r+1,a[i].k); } else{ add(1,-a[i].k); add(a[i].r+1,a[i].k); add(a[i].l,-a[i].k); } } for (int i=1;i&lt;=n;i++) a[l+i-1]=Left[i]; for (int i=1;i&lt;=m;i++) a[l+n+i-1]=Right[i]; solve(L,mid,l,l+n-1); solve(mid+1,R,l+n,r); } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;x); vec[x].push_back(i); } for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]); scanf(&quot;%d&quot;,&amp;k); for (int i=1;i&lt;=k;i++){ scanf(&quot;%d%d%lld&quot;,&amp;a[i].l,&amp;a[i].r,&amp;a[i].k); a[i].isq=false; a[i].num=i; } for (int i=1;i&lt;=n;i++){ a[i+k].k=t[i]; a[i+k].isq=true; a[i+k].num=i; } solve(1,k+1,1,k+n); for (int i=1;i&lt;=n;i++) if (ans[i]!=k+1) printf(&quot;%d\\n&quot;,ans[i]); else puts(&quot;NIE&quot;); return 0; } 6.2 CDQ分治（三维偏序） #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN=110000; const int MAXM=210000; struct node{ int s,c,m,num,tot; } t[MAXN],a[MAXN]; int n,k,cnt,tree[MAXM],tot[MAXN],num[MAXN],ans[MAXN]; inline void add(int x,int y){ for (;x&lt;=k;x+=x&amp;(-x)) tree[x]+=y; } inline int getsum(int x){ int sum=0; for (;x;x-=x&amp;(-x)) sum+=tree[x]; return sum; } inline int cmp1(node a,node b){ return (a.s&lt;b.s)||(a.s==b.s&amp;&amp;a.c&lt;b.c)||(a.s==b.s&amp;&amp;a.c==b.c&amp;&amp;a.m&lt;b.m); } inline int cmp2(node a,node b){ return (a.c&lt;b.c)||(a.c==b.c&amp;&amp;a.m&lt;b.m); } void CDQ(int l,int r){ if (l==r){ tot[a[l].num]+=a[l].tot-1; return; } int mid=(l+r)&gt;&gt;1; CDQ(l,mid); CDQ(mid+1,r); sort(a+l,a+mid+1,cmp2); sort(a+mid+1,a+r+1,cmp2); int i,j; for (i=l,j=mid+1;j&lt;=r;j++){ for (;i&lt;=mid&amp;&amp;a[i].c&lt;=a[j].c;i++) add(a[i].m,a[i].tot); tot[a[j].num]+=getsum(a[j].m); } while ((--i)&gt;=l) add(a[i].m,-a[i].tot); } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;t[i].s,&amp;t[i].c,&amp;t[i].m); sort(t+1,t+n+1,cmp1); for (int i=1;i&lt;=n;i++) if (i==1||t[i-1].s!=t[i].s||t[i-1].m!=t[i].m||t[i-1].c!=t[i].c){ a[++cnt]=t[i]; a[cnt].tot=1; a[cnt].num=cnt; } else a[cnt].tot++; for (int i=1;i&lt;=cnt;i++) num[i]=a[i].tot; CDQ(1,cnt); for (int i=1;i&lt;=cnt;i++) ans[tot[i]]+=num[i]; for (int i=0;i&lt;n;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0; } 7. 计算几何 7.1 基础模板 struct Point{ double x,y; Point(double x=0,double y=0):x(x),y(y){} }; typedef Point Vector; Vector operator+(Vector A,Vector B){ return Vector(A.x+B.x,A.y+B.y);} Vector operator-(Point A,Point B){ return Vector(A.x-B.x,A.y-B.y);} Vector operator*(Vector A,double p){ return Vector(A.x*p,A.y*p);} Vector operator/(Vector A,double p){ return Vector(A.x/p,A.y/p);} const double eps=1e-6; int sgn(double x){ if (fabs(x)&lt;eps) return 0; if (x&lt;0) return -1; return 1; } bool operator==(const Point&amp; a,const Point&amp; b){ if (sgn(a.x-b.x)==0&amp;&amp;sgn(a.y-b.y)==0) return true; return false; } double Dot(Vector A,Vector B){ return A.x*B.x+A.y*B.y;} double Length(Vector A){ return sqrt(Dot(A, A));} double Angle(Vector A,Vector B){ return acos(Dot(A,B)/Length(A)/Length(B));} double Cross(Vector A,Vector B){ return A.x*B.y-A.y*B.x;} double Area(Point A,Point B,Point C){//计算两向量构成的三角形形有向面积 return Cross(B-A,C-A)/2; } double Area2(Point A,Point B,Point C){//计算两向量构成的平行四边形有向面积 return Cross(B-A,C-A); } Vector Rotate(Vector A,double rad){//rad为弧度 且为逆时针旋转的角 return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad)); } Vector Normal(Vector A){//向量A左转90°的单位法向量 double L=Length(A); return Vector(-A.y/L,A.x/L); } bool ToLeftTest(Point a,Point b,Point c){ return Cross(b-a,c-b)&gt;0;} double DistanceToLine(Point P,Point A,Point B){//点P到直线AB距离公式 Vector v1=B-A,v2=P-A; return fabs(Cross(v1,v2)/Length(v1));//不去绝对值，得到的是有向距离 } double DistanceToSegment(Point P,Point A,Point B){//点P到线段AB距离公式 if (A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if (dcmp(Dot(v1,v2))&lt;0) return Length(v2); if (dcmp(Dot(v1,v3))&gt;0) return Length(v3); return DistanceToLine(P,A,B); } 8.矩阵 ## 4.6 矩阵基础模板 ​```cpp struct matrix{ int v[55][55]; matrix(){ memset(v,0,sizeof(v));} int det(){ int res=1; for (int i=1;i&lt;=K;i++){ if (!v[i][i]){ for (int j=i+1;j&lt;=K;j++) if (v[j][i]){ swap(v[i],v[j]); break;} res=dec(0,res); if (!v[i][i]) return 0; } ll inv=getinv(v[i][i]); for (int j=i+1;j&lt;=K;j++){ int tmp=mul(v[j][i],inv); for (int k=i;k&lt;=K;k++) v[j][k]=dec(v[j][k],mul(tmp,v[i][k])); } } for (int i=1;i&lt;=K;i++) res=mul(res,v[i][i]); return res; } friend matrix operator+(const matrix &amp;a,const matrix &amp;b){ matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=add(a.v[i][j],b.v[i][j]); return res; } friend matrix operator-(const matrix &amp;a,const matrix &amp;b){ matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=dec(a.v[i][j],b.v[i][j]); return res; } friend matrix operator*(const matrix &amp;a,const int b){ matrix res; for (int i=1;i&lt;=K;i++) for (int j=1;j&lt;=K;j++) res.v[i][j]=mul(a.v[i][j],b); return res; } friend matrix operator*(const matrix &amp;a,const matrix &amp;b){ matrix res; for (int i=1;i&lt;=K;i++) for (int k=1;k&lt;=K;k++) if (a.v[i][k]) for (int j=1;j&lt;=K;j++) res.v[i][j]=add(res.v[i][j],mul(a.v[i][k],b.v[k][j])); return res; } friend matrix operator^(matrix x,int a){ matrix res; for (int i=1;i&lt;=K;i++) res.v[i][i]=1; while (a){ if (a&amp;1) res=res*x; x=x*x; a&gt;&gt;=1; } return res; } }; ToDo List：多项式多点插值 ","link":"https://hydd-new.github.io/Templates/"},{"title":"CF1188D","content":" 给定 nnn 个数字 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​，每次操作可以给某个 aia_iai​ 加上 222 的非负整数次幂。 求最少的操作次数使得 nnn 个数相等。 1≤n≤105,0≤ai≤10171\\leq n\\leq 10^5,0\\leq a_i\\leq 10^{17}1≤n≤105,0≤ai​≤1017 sol 不妨先将 aaa 从小到大排序。 设最后每个数都等于 an+x(x≥0)a_n+x(x\\geq 0)an​+x(x≥0)。那么总代价为 ∑i=1npopcount(an+x−ai)\\sum\\limits_{i=1}^n popcount(a_n+x-a_i)i=1∑n​popcount(an​+x−ai​)。 现在要找一个 xxx 使得答案最小。不妨先将 aia_iai​ 变为原先的 an−aia_n-a_ian​−ai​。 那么现在总代价为 ∑i=1npopcount(x+ai)\\sum\\limits_{i=1}^n popcount(x+a_i)i=1∑n​popcount(x+ai​)。 从低到高考虑每一位，那么 x+aix+a_ix+ai​ 的第 kkk 位是 0/10/10/1 由以下三个条件决定： xxx 的第 kkk 位是 000 还是 111 aia_iai​ 的第 kkk 位是 000 还是 111 x+aix+a_ix+ai​ 的第 k−1k-1k−1 位有没有向前进位 暴力的做法是从低到高枚举每一位，用 2n2^n2n 的状态记录每个数有没有进位，显然复杂度接受不了。 但是可以发现，由于每个 aia_iai​ 加的都是 xxx，所以 aia_iai​ 的后 k−1k-1k−1 位越大，越可能向第 kkk 位进位。 所以，“每个数有没有进位”的状态数只有 O(n)O(n)O(n) 个，每个进位状态为后 k−1k-1k−1 位从小到大排序后的一个后缀。 记 f[k][i]f[k][i]f[k][i] 表示考虑了后 kkk 位，后 kkk 位最大的 iii 个数进位的最小代价。 如何转移？考虑当前这一位 xxx 是 000 还是 111。 0： 对答案的贡献：“前一位没进位且第 kkk 位为 111 的数“的个数 + ”前一位进位且第 kkk 位为 000 的数“的个数（x+aix+a_ix+ai​ 在这一位为 111）； 进位的数量：&quot;前一位进位且第 kkk 位为 111 的数&quot;的个数。 1： 对答案的贡献：“前一位进位且第 kkk 位为 111 的数“的个数 + ”前一位没进位且第 kkk 位为 000 的数“的个数（x+aix+a_ix+ai​ 在这一位为 111）； 进位的数量：n−n-n−&quot;前一位没进位且第 kkk 位为 000 的数&quot;的个数。 至于如何求这些“个数”，就记个前缀和，存下后 kkk 位从小到大前 iii 个中没进位数的个数和进位的数的个数即可。 可以用类似于基数排序的方法优化每次的排序，时间复杂度 O(nlog⁡V)O(n \\log V)O(nlogV)，其中 V=max⁡aiV=\\max{a_i}V=maxai​。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const ll INF=1ll&lt;&lt;60; int n,p[510000],sum[2][510000]; int tmp1[510000],tmp2[510000]; ll dp[60][510000],c1,c2,c3,p1,p2,m; ll sta,a[510000]; /*bool cmp(int x,int y){ return (a[x]&amp;sta)&lt;(a[y]&amp;sta); }*/ int main(){ // freopen(&quot;equal.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;equal.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); sort(a+1,a+n+1); for (int i=1;i&lt;=n;i++) a[i]=a[n]-a[i]; for (int w=0;w&lt;=58;w++) for (int i=0;i&lt;=n;i++) dp[w][i]=INF; for (int i=1;i&lt;=n;i++) p[i]=i; dp[0][0]=0; for (int w=0;w&lt;58;w++){ sta=(1ll&lt;&lt;w)-1; // sort(p+1,p+n+1,cmp); for (int i=1;i&lt;=n;i++){ sum[0][i]=sum[0][i-1]; sum[1][i]=sum[1][i-1]; sum[(a[p[i]]&gt;&gt;w)&amp;1][i]++; } for (int i=0;i&lt;=n;i++){ int tmp=(sum[0][n]-sum[0][n-i])+sum[1][n-i]; int sta=sum[1][n]-sum[1][n-i]; dp[w+1][sta]=min(dp[w+1][sta],dp[w][i]+tmp); } for (int i=0;i&lt;=n;i++){ int tmp=(sum[1][n]-sum[1][n-i])+sum[0][n-i]; int sta=n-sum[0][n-i]; dp[w+1][sta]=min(dp[w+1][sta],dp[w][i]+tmp); } int cnt1=0,cnt2=0; for (int i=1;i&lt;=n;i++) if ((a[p[i]]&gt;&gt;w)&amp;1) tmp1[++cnt1]=p[i]; else tmp2[++cnt2]=p[i]; int k=0; for (int i=1;i&lt;=cnt2;i++) p[++k]=tmp2[i]; for (int i=1;i&lt;=cnt1;i++) p[++k]=tmp1[i]; } printf(&quot;%lld\\n&quot;,dp[58][0]); return 0; } ","link":"https://hydd-new.github.io/CF1188D/"},{"title":"CF555E","content":" 给定一个 nnn 个点 mmm 条边的无向图。有 qqq 个人，第 iii 个人要从 sis_isi​ 到 tit_iti​。 现在你要给无向图的每条边定向。问是否存在一种定向方法使得所有人都能够到达目的地。 n,m,q≤2×105,ui≠vi,si≠tin,m,q\\leq 2\\times 10^5,u_i\\neq v_i,s_i\\neq t_in,m,q≤2×105,ui​​=vi​,si​​=ti​ sol 我的做法（186ms） 可以发现，对于一个边双来说，一定存在一种定向方法，使得边数内两两点之间均可到达。 所以一个边双相当于一个点。那么我们缩点，把图变成一颗树。这样，sss 到 ttt 只能走树上简单路径。 我们把 s→LCAs\\rightarrow LCAs→LCA 的路径打向上的标记，把 LCA→tLCA\\rightarrow tLCA→t 的路径打向下的标记。LCALCALCA 可以通过倍增预处理。 只要没有一条边同时有两种标记，就是合法的。打标记使用树上差分实现。 时间复杂度：$ O(n+m+q\\log n)$。 细节 原图不保证连通，所以在缩点，预处理倍增，判断答案的时候要在每个连通块都做一次。 原图可能有重边，所以 tarjan\\rm tarjantarjan 的时候要记上一条边的编号而不是父亲节点。 /********************************************************************* * Problem：CF555E * Author：hydd * Date：2020/8/30 - 2020/8/31 *********************************************************************/ #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; //#define File(x) freopen(x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(x&quot;.out&quot;,&quot;w&quot;,stdout) using namespace std; const int MAXN=210000; const int MAXM=410000; int n,m,q,u[MAXN],v[MAXN]; int top,st[MAXN],fr[MAXN],dep[MAXN]; int cnt2,fa[MAXN][19]; bool vis[MAXN]; int cnt,num[MAXN],up[MAXN],dw[MAXN]; int dtime,dfn[MAXN],low[MAXN]; vector&lt;int&gt; vec[MAXN]; int edgenum=1,vet[MAXM],Next[MAXM],Head[MAXN]; void addedge(int u,int v){ vet[++edgenum]=v; Next[edgenum]=Head[u]; Head[u]=edgenum; } char Getchar(){ static char now[1&lt;&lt;20],*S,*T; if (T==S){ T=(S=now)+fread(now,1,1&lt;&lt;20,stdin); if (T==S) return EOF; } return *S++; } int read(){ int x=0,f=1; char ch=Getchar(); while (ch&lt;'0'||ch&gt;'9'){ if (ch=='-') f=-1; ch=Getchar(); } while (ch&lt;='9'&amp;&amp;ch&gt;='0') x=x*10+ch-'0',ch=Getchar(); return x*f; } void tarjan(int u,int le){//2. dfn[u]=low[u]=++dtime; st[++top]=u; int v; for (int e=Head[u];e;e=Next[e]){ v=vet[e]; if (e==(le^1)) continue; if (!dfn[v]){ tarjan(v,e); low[u]=min(low[u],low[v]); } else low[u]=min(low[u],dfn[v]); } if (dfn[u]==low[u]){ cnt++; while (st[top]!=u){ num[st[top]]=cnt; top--;} num[st[top]]=cnt; top--; } } void dfs(int u,int f){ fr[u]=cnt2; dep[u]=dep[f]+1; fa[u][0]=f; for (int i=1;(1&lt;&lt;i)&lt;dep[u];i++) fa[u][i]=fa[fa[u][i-1]][i-1]; for (int v:vec[u]){ if (v==f) continue; dfs(v,u); } } void dfs2(int u,int f){ vis[u]=true; for (int v:vec[u]){ if (v==f) continue; dfs2(v,u); up[u]+=up[v]; dw[u]+=dw[v]; } } int LCA(int x,int y){ if (dep[x]&lt;dep[y]) swap(x,y); int d=dep[x]-dep[y]; for (int i=0;i&lt;=18;i++) if (d&amp;(1&lt;&lt;i)) x=fa[x][i]; if (x==y) return x; for (int i=18;i&gt;=0;i--) if (fa[x][i]!=fa[y][i]){ x=fa[x][i]; y=fa[y][i]; } return fa[x][0]; } bool check(){ int s,t; while (q--){ s=read(); t=read(); s=num[s]; t=num[t]; if (fr[s]!=fr[t]) return false; int w=LCA(s,t); up[s]++; up[w]--; dw[t]++; dw[w]--; } for (int i=1;i&lt;=n;i++) if (!vis[i]) dfs2(i,0);//1. for (int i=1;i&lt;=cnt;i++) if (up[i]&amp;&amp;dw[i]) return false; return true; } int main(){ n=read(); m=read(); q=read(); edgenum=1; for (int i=1;i&lt;=m;i++){ u[i]=read(); v[i]=read(); addedge(u[i],v[i]); addedge(v[i],u[i]); } for (int i=1;i&lt;=n;i++) if (!dfn[i]) tarjan(i,0);//1. int x,y; for (int i=1;i&lt;=m;i++){ x=num[u[i]]; y=num[v[i]]; if (x==y) continue; vec[x].push_back(y); vec[y].push_back(x); } for (int i=1;i&lt;=cnt;i++) if (!fr[i]){ cnt2++; dfs(i,0);}//1. if (check()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 可以使用 tarjan\\rm tarjantarjan 求 LCALCALCA 得到更优的时间复杂度 O(n+m+q)O(n+m+q)O(n+m+q)。 ","link":"https://hydd-new.github.io/CF555E/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hydd-new.github.io/hello-gridea/"}]}