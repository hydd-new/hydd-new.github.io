{"posts":[{"title":"贪心","content":"贪心 1472F 从左到右考虑每一列， 确定了前 i−1i-1i−1 列，那么现在的第 iii 列哪些被覆盖就确定了。 可以求出第 iii 列覆盖的方案：如果没有空格/只有一个空格，则只能放横的；否则两个都是空格，一种是放两个横的，一种是放一个竖的，可以发现放两个横的和放两个竖的等价，不如变成放竖的，其它的之后再决策。 所以就变成，只要这一列没满，就横着放，否则竖着放。 有一种离谱情况，它是第一行放(1,2),(3,4),...，第二行放的是(2,3),(4,5),...，类似于这种就必须横着放。 那么你就可以O(m)模拟，你这一列覆盖完之后就知道后面的是上下两行差1的情况还是可以直接竖着放。 从有障碍的一列到后一个有障碍的一列，中间快速跳。 1367F 我们直接来做F2。首先可以离散化，然后发现每个数最多操作一次，不然你可以只操作最后的那一次。 根据经典套路，你把不动的拿出来，一定是个递增序列，剩下的也得能归位（比最小值小或比最大值大，也就是&gt;最小&lt;最大的必须本身在序列内）。 直接设 dp[i]dp[i]dp[i] 表示 iii 选了且是最大的最长长度，a[i]=xa[i]=xa[i]=x。一种从之前的最后一个 xxx 转移过来；一种是选所有的 x−1x-1x−1（必须在 iii 前面），再从第一个 x−1x-1x−1 转移过来；还有一种是选之前所有的 x−1x-1x−1。 分别求出来转移即可。 1373E（#） 考虑 x+kx+kx+k 进没进位。 如果没进位，枚举最后一位，之前的位贪心（尽量填9）。 如果进位了，枚举最后一位和之前连续的9的长度，计算一下，再贪心（先填一个8，再尽量填9）。 1530E（#） 如果只有一种字符，那只有一种方法，直接结束。 f为0：如果有某种字符只出现一次，那么拿最小的只出现一次的字符当开头，其它的从小到大往后排（不可能拿出现果不止一次的字符，那会使得f至少为1；也不可能取更大的字符，那字典序更大）。 f为1：现在所有字符都出现至少两次（这种情况答案一定不为0，不妨假设a出现了），想让字典序尽量小，先考虑有没有可能是以aa开头，那么之后就不能有两个相邻的a（否则f至少为2），只能形如aababa…ca…。可以发现a的个数最多为其它数字个数+2，即cnt&gt;=n-cnt+2，cnt&gt;=n/2+1。 如果不满足条件（不妨假设b出现了），考虑开头为ab，那么之后就不能再出现ab，如果只有两种字符，那么b一定要出现在a前面，即abbb…baa…a；如果有更多字符（不妨假设c出现了），那么可以为abaaa…acbbb...bccc…c…，即ab之后填所有的a，再填c，剩下的从小到大填。 1254B2（#） 只需要考虑 kkk 是质数的情况。 其实 aia_iai​ 和 ai mod ka_i \\bmod kai​modk 是完全等价的（不会出现负数啥的情况），那么前面往后移和后面往前移也是等价的，计算一下答案即可。 576C（#） 按照莫队的方法奇偶排序即可。 547A（#） 你先暴力跳，把第一个跳满足，如果跳了 mmm 次还不满足就无解。 如果此时第二个也满足就直接结束。 否则你让第一个就再跳一个环回，跳回来，记录此时第二个乘的x和加的y。 之后再跳第一个就不变了，依旧暴力跳，不超过m次。 1253E 对于原问题，可以加入一个 [0,0] 的区间，这样不会影响答案（可以把第二个区间多扩展这个区间的范围）。 设 dpidp_idpi​ 表示只用中心不超过 iii，覆盖 1..i1..i1..i 的最小代价。有了 [0,0][0,0][0,0] 就不存在不能覆盖的问题了。 如果原先覆盖了 ii i 那么从之前没覆盖的第一个位置转移，否则直接考虑之前的某一个扩展到 iii，再从左端点之前转移过来。 但是你可以扩展得更长，多覆盖左边的一点，这样就很麻烦了。但是 dpi+1≤dpi+1dp_{i+1}\\leq dp_i+1dpi+1​≤dpi​+1，你可以把之前的区间增加 111。 1316E 排序，变成 aia_iai​ 从大到小排序。 范围很小，直接状压 dpdpdp 记录到哪一个，之前队伍有了哪几个位置（状态），有多少名观众。 如果当前放进队伍就枚举放哪个位置，不放进队伍如果观众不够就当观众，否则就不参加。 1296F（#） 显然要满足 u,vu,vu,v 路径上的边权都 ≥w\\geq w≥w。 路径取 max⁡\\maxmax 后判断是否合法即可。 1334E（#） 考虑路径会长成什么样，直观的想法是先除后乘一定严格比先乘后除优，不妨反证。考虑从x到x*p/q。 设p,q为两个不等质数，先乘后除：-d(x)+d(xp)+d(xp)-d(xp/q)，先除后乘：d(x)-d(x/q)-d(x/q)+d(xp/q) 要求-d(x)+d(xp)+d(xp)-d(xp/q)&lt;=d(x)-d(x/q)-d(x/q)+d(xp/q)，整理得2d(x)-2d(xp)+2d(xp/q)-2d(x/q)&gt;0. 都除以2，移项变成d((x/q)p)-d(x/q)&gt;=d(xp)-d(x)，可以知道，*p之后增加量应该数字除去所有p之后，剩下的因子数，(x/q)|x，这个式子一定不成立。（为啥不考虑p=q呢，因为边权一定为正，没必要从x到x）。 所以一定会先除后乘，否则可以交换顺序。那么可以变成x一直除，y一直除，到达同一个点。 由于你只是除，那么路径上的中间点的权值都会删去，所以路径长度一定是d(x)-d(目标点)。 那么答案是d(x)+d(y)-2d(目标点)，x,y都能到达的点只能是g=gcd(x,y)的约数，可以发现g的约数中，g本身的d(g)是严格最大的，所以目标点也固定为g。答案就是x到g的方案数*y到g的方案数。 相当于要求一个数x，每次除一个质因数，有多少种不同的方法，那么就用tot!/(p1!p2!...pk!)算算多重组合。 由于题目说了给的都是D的约数，先求出D的所有质因子，询问的时候就可以O(log V)解决。 1384B2（#） 称无论什么时候在当前位置都是安全的点为安全点，否则为不安全点。显然不安全点能走的时间是一些区间。 若当前点为安全点且下一个点也是安全点，直接走过去即可； 若当前点为安全点且下一个点不是安全点，则在最优的时间走过去（递减且正好能走过去）。 若当前点不为安全点且下一个点是安全点，直接走过去即可； 若当前点不为安全点且下一个点不是安全点，则只要能走过去且不死就走过去，一直不走必定会死，能跑路就赶紧跑路。 549G（#） 继续寻找不变量，ai+ia_i+iai​+i 总是不变的。 初始的 ai+=ia_i+=iai​+=i，条件变为：ai−1≥aia_{i-1}\\geq a_iai−1​≥ai​ 的话交换 ai−1,aia_{i-1},a_iai−1​,ai​。 如果有相等的显然最后会一直交换，否则最后会排序，再 −i-i−i 输出即可。 825E（#） 你直接按照顺序拓扑排序，把小的给编号小的，求出的是答案对应的逆排列最小。（编号小的其实是越早经过越优）。 非常有意思的一点是，你如果建反图，尽量把大的给编号大的，这样求出的就是答案最小。（现在越早经过反而变成越劣，反过来了）。 1411D（#） 把贡献分成几种情况，0和1，?和1，0和?，?和?。 可以知道，把序列分成若干部分，它们之间形成的01/10子序列和内部顺序无关。 考虑?...?，它们和外部的贡献和顺序无关，和0,1出现次数有关。如果?替换从0,0或1,1的出现次数不同。 替换成0,1和1,0出现次数相同，内部的贡献比较变为0...1和1...0哪个大，设中间的...有a个0，b个1，那么0,1的贡献是(a+b+1)x，1,0的贡献是(a+b+1)y，看x,y哪个大变成哪个即可。 不妨设x比较大，所以?填的一定是前面若干个0，后面若干个1，枚举前面多少个填0，可以计算出?和?，而其它三种预处理即可。 1154F 可以发现一定选最便宜的 kkk 双，因为如果选了 xxx 有一个更小的 yyy 没选，那么如果本身 xxx 被免费，那么换成 yyy 之后一定也免费；如果 xxx 不免费，一种是换成 yyy 之后也不免费，一种是换了变免费了，那么有一个变收费了，变收费的一定比 xxx 小，总代价也变小。 排序。总和固定，你希望免费的鞋的钱的价格尽量高，所以你会成段成段的买。 然后dp，枚举最后一次买了多少双鞋，计算一下代价。 1535E 这题关键在于： 保证 ci&gt;cpic_i&gt;c_{p_{i}}ci​&gt;cpi​​，所以删的一定是到根路径上的前缀； 操作是有后效性的（永久的）。 删的一定是到根路径上的一个前缀，删除的时间可以均摊。 怎么找最上面的点？考虑倍增（主要是方便在线加点），找到最上面没被删的点即可。 1154G（#） 拿个桶记录每个数有没有出现过。 lcm可能很大，但lcm(a,b)=ab/gcd(a,b)，考虑枚举gcd和它的倍数，求两个最小的出现过的更新答案即可。 1556E 可以发现，设 ci=bi−aic_i=b_i-a_ici​=bi​−ai​，那么就变成选出下标递增的 kkk 个位置 −1,+1,−1,+1,...,−1,+1-1,+1,-1,+1,...,-1,+1−1,+1,−1,+1,...,−1,+1，要求所有数都是 000。 显然和不变，所以和必为 000 才有解。根据经典套路，做个前缀和还是要求所有数都是 000，就变成区间 −1-1−1（最后一个数不能动，也说明和必须为 000），如果原先有负数显然无解。 由于每次可以任意选区间，所以答案就是最大值。 先全局做一次，维护一下区间最大最小值，再都减去 l−1l-1l−1 的前缀和，如果最小值 &lt;0&lt;0&lt;0 则无解，再判断 rrr，如果是 000 也无解，最后再输出最大值。 1494D（#） LCA 的权值为最大值的，说明它们 LCA 为根。 LCA 的权值不为最大值的，说明它们在根节点同一子树。 递归下去即可。 1557D 设 fif_ifi​ 表示 1..i1..i1..i 行能选出多少行使得选出的数量最多（第 iii 行必选）。 如果第 iii 行和第 j(j&lt;i)j(j&lt;i)j(j&lt;i) 行能相邻，fif_ifi​ 就可以从 fj+1f_j+1fj​+1 转移。 判相邻就看是否有一列相交，不妨转变思路，直接把有第 xxx 列的放到线段树上取最大值，求 fif_ifi​ 就在 iii 有的区间上取最大值即可。 答案是 n−max⁡fin-\\max f_in−maxfi​。 1605D 首先看条件 u⊕v≤min(u,v)u \\oplus v\\leq min(u,v)u⊕v≤min(u,v)，不妨设 u&lt;vu&lt;vu&lt;v，如果 u,vu,vu,v 最高位不同，那么 u⊕vu\\oplus vu⊕v 的最高位就是 vvv 的最高位，比 uuu 大，矛盾。如果最高位相同，直接异或掉了，一定满足。 所以条件就变为 u,vu,vu,v 最高位相同。由于是轮流操作，你还可以把树黑白染色。 显然所有点都不能动的构造最大。看黑白两边的节点个数 x,yx,yx,y，不妨设 x≤yx\\leq yx≤y。 最高位不同的数之间相互独立，把 xxx 二进制分解，最高位是那些的都放到 xxx，剩下的都放到 yyy。 那么所有点相邻的都没有同最高位的，所以都不能走。 1175E 用一个区间覆盖第 iii 个点，假设之前都覆盖了，那么右端点一定越靠右越好。 求出覆盖第 iii 个点的右端点最右的区间，扫一遍取 max⁡\\maxmax，建边指向右端点右边那个点。 现在变成一个森林， 从 lll 开始跳几步才能 ≥r\\geq r≥r，倍增即可。 1271D 对于一个城堡，你一定尽量晚的放士兵，因为如果你之前不放后来放， 影响是中间那一段时间军中的人数增加 111，不会更劣。 由于你会走过每一个城堡，记录哪些是在这个城堡才会选的驻守方案，如果不往那些驻守之后就守不了了。 直接二维 dpdpdp 记到哪一个还有多少人是一定可以的。不这么做，考虑带悔贪心。 因为你必须走到底，所以你可以先在最后能驻守的时候先驻守，行军人数不够就反悔把之前的抽出来，但是你走过去之后，就不能把这些人放回去了（他们必须跟过来），所以复杂度是对的。 1220E（#） 因为保证了图连通，考虑拓扑排序。 排序完之后剩下的还在图中的，它们一定可以一次走完并且停在任何一个点。 就分进入环还是不进入环的情况，可以（对被删去的点）处理一个f数组表示从度数为0的点开始到这个点的最大权值，同时更新不经过环的答案，最后把不删的点之和+f的最大权值。 1404C（#） 如果询问的是整个序列，那么每次删除最后一个满足 ai=ia_i=iai​=i 的位置即可，把删除顺序记作 bib_ibi​。 询问的不是整个序列，找第一个 bi&lt;xb_i&lt;xbi​&lt;x，在之前的 bi≤yb_i\\leq ybi​≤y 的都对答案产生了 111 的贡献，计算即可。 1511E 横着的和竖着的是独立的，横/竖的极长连续段之间也是独立的。 如果有一段长度为 xxx 的横/竖的极长连续段，设它的答案为 f[x]f[x]f[x]，那么对应的贡献为 f[x]∗2tot−xf[x]*2^{tot-x}f[x]∗2tot−x（tottottot 是总白色格子数量，即剩下可以任意选）。 考虑 f[i]f[i]f[i] 的转移： iii 位置是另一种颜色，从 f[i−1]f[i-1]f[i−1] 转移过来； iii 位置是这种颜色，i−1i-1i−1 不是这种颜色，从 f[i−2]f[i-2]f[i−2] 转移过来； iii 位置是这种颜色，i−1i-1i−1 也是这种颜色，从 f[i−2]+2i−2f[i-2]+2^{i-2}f[i−2]+2i−2 转移过来（后面加的是之前的方案数）。 横竖都算一边加起来即可。 1029E（#） 看上去比较像贪心，首先新的边一定一端是1，否则不优（你是要减小最短路，看减小的是哪边，不妨把另一边换成1）。考虑哪些点的策略一定是固定的。 考虑一个还不满足条件的叶子节点，那么一定要把它或它的父亲和1连边，连谁比较优呢。 发现一定会连它的父亲，它父亲会使得满足条件的更多，且除了它本身以外其它点的最短路更小。 对于满足条件的叶子节点，可以发现能把其删掉，选它也不如选它的父亲。 所以你每次选一个深度最深的叶子节点做，然后删去，更新它父亲的深度。 767B 你考虑，如果你要在前面一些老哥之后，这个老哥之前， 那么你在之前的任何时间点来和后面这个老哥来的前一秒来是没区别的。 所以你就对于每个老哥，看在这个老哥前一秒来要等多少时间（等不等得到，now+m&gt;Tenow+m&gt;T_enow+m&gt;Te​ 就等不到了）。之前要占多少时间可以直接拿个数字记录，即之前的人都走完需要多久，减一下更新答案。 1415E（#） 相当于分成最多k+1个序列，每个序列再按照顺序计算。 可以贪心考虑，显然分出的每个序列都是从大到小排序最好。 用堆维护每个序列当前的和，找到最大的序列加上当前的数。 679B 考虑能不能变成规模更小的子问题。 求出最大的 xxx 满足 x3≤nx^3\\leq nx3≤n，那么最后答案中，第一步取的一定不超过 xxx。 如果第一步取 xxx，那么剩下的可以是 [0,n−x3][0,n-x^3][0,n−x3] 中的任何数（初始在 [x3,n][x^3,n][x3,n]）。 如果第一步取 x−1x-1x−1，那么剩下的可以是 [0,x3−1−(x−1)3][0,x^3-1-(x-1)^3][0,x3−1−(x−1)3] 中的任何数（初始在 [(x−1)3,x3−1][(x-1)^3,x^3-1][(x−1)3,x3−1]）。 初始取比 x−1x-1x−1 更小的一定不如取 x−1x-1x−1，剩下的范围更大。 那么也就是说能递归到 max⁡(n−x3,x3−1−(x−1)3)\\max(n-x^3,x^3-1-(x-1)^3)max(n−x3,x3−1−(x−1)3) 的子问题，nnn 的答案是它的答案 +1+1+1。 不过比较低素质的是相同的情况下让体积最大，所以你求出答案之后还得看到底取哪边可以，都可以就尽量取大的。 这个递归复杂度是 O(n13)O(n^{\\frac 13})O(n31​)。 1528C 可以发现，第一棵树取得一定是祖孙链。 在两棵树上都保证了 fai&lt;ifa_i&lt;ifai​&lt;i，所以你枚举第一棵树的祖孙链的时候，如果第二棵树的这个点和之前的点（最多只有一个）有祖孙关系，一定用这个点替代之前的点（dfsdfsdfs 序的区间严格被之前的包含）。 1396C 由于 r1≤r2≤r3r_1\\leq r_2\\leq r_3r1​≤r2​≤r3​，而手枪和AWP都只能打一只怪物，所以AWP只可能用来打BOSS。 如果用手枪一只一只打小怪，最后一定是一起把BOSS一起解决了（不解决放着之后需要的时间不会更少）。 如果用激光枪，那么打完一定要走，如果之前 i−1i-1i−1 BOSS也没死，就去打 i−1i-1i−1，否则打 i+1i+1i+1（你之后还得打 i−1i-1i−1 的BOSS，不如现在先去了）。 不过即使你用手枪打， 如果 i−1i-1i−1 的BOSS没死，你打完后一定也是先去 i−1i-1i−1，之后再折返一定不优。 所以说，假设 iii 之前的怪全都死了，一种是你用手枪+AWP解决，到 i+1i+1i+1；另一种是用激光枪/手枪给每个打一枪，然后到 i+1i+1i+1，再用任意方法（都打一枪或直接解决），再回到 iii，手枪一枪打死BOSS，又到 i+1i+1i+1，如果BOSS没死也一枪打死，最后到 i+2i+2i+2。 所以一种是新增 ai×r1+r3+da_i\\times r_1+r_3+dai​×r1​+r3​+d 的代价走到 i+1i+1i+1，一种是新增 min⁡((ai+1)×r1,r3)+r1+min⁡(min⁡((ai+1+1)×r1,r3)+r1,ai+1×r1+r3)+4d\\min((a_i+1)\\times r_1,r_3)+r_1+\\min(\\min((a_{i+1}+1)\\times r_1,r_3)+r_1,a_{i+1}\\times r_1+r_3)+4dmin((ai​+1)×r1​,r3​)+r1​+min(min((ai+1​+1)×r1​,r3​)+r1​,ai+1​×r1​+r3​)+4d走到 i+2i+2i+2。 dp即可。 675E 从后往前维护后缀最大值（是指 i..j−1i..j-1i..j−1 中的所有值都比 a[j]a[j]a[j] 小）。 那么你从这个点开始， 走到的点一定在这个点开始的后缀最大值的集合内。 而且，后缀最大值也不一定会出现，如果这个点能直接走到下下个点，那么下一个点也没用了。 用单调栈维护这个集合，同时维护这个集合中的位置之和来计算答案。 1202C 行列独立，分别处理，以行为例：先求不操作得到的最小/最大值。 现在要让最大值-1（或最小值+1）,显然当当前值第一次等于最大值（最小值）的时候必须是有-1（+1）。 然后更新操作后的最小最大值，列同理。再计算一下。 1203F2 同F1，加血的没区别（按照 aia_iai​），扣血的你利用调整法，发现也差不多，按照 ai+bia_i+b_iai​+bi​ 的顺序从大到小。 加血显然能加就加，扣血的现在可以选择扣不扣，跑个背包即可。 1108F（#） 和MST有关的，很多贪心都是对的。。。 随便取一棵生成树，不妨假设最后留下的就是这棵生成树。 那么你对于剩下的非树边，和树边一定形成了一个环，它不能替换环上的其它边，即要比其它边都严格大。 考虑边kruskal边计算答案，发现后面加入的边如果需要增加当且仅当在加入同权值的边之前是不连通的，加了同权值的边后连通，为了不让自己替换那条边所以要+1。 同权值的一起计算即可。 754D 按照左端点从小到大排序。 把右端点加入小根堆，每次弹堆顶保证不超过 k 个数。 如果有 k 个那么用最小值-当前左端点+1更新答案。 1152D 你考虑类似二分图匹配，左部是深度为奇数的点，右部为深度为偶数的点。 答案不超过两部大小较小值。容易构造出答案为左部大小的答案， 即每个深度为奇数的点选一个儿子（一定能选出）。 按照左端点从小到大排序。 把右端点加入小根堆，每次弹堆顶保证不超过 k 个数。 如果有 k 个那么用最小值-当前左端点+1更新答案。 976E 明显*2只给同一个人最优。 剩下的一定是选替换掉新增的贡献最大的若干个。 排序求一下即可。 1398E（#） 设电的数量为x。可以发现，理想的情况是你给最大的x个翻倍。 但是有可能不行，因为可能最大的x个都是电，这样一定有一个翻不了，可以发现一定不翻最小的。 而且，如果最大的x个中有火，你就从一个不用翻的电开始就可以了，此时一定没有最小的电。 所以无论什么情况，都不会翻最小的电。你要求的是答案尽量大。 如果x大有火则为S+S1，否则为S+S2-M（S为所有和，S1为前x大和，S2为前x+1大和，M为最小的电）。 可以用set维护前x+1大，相同的认为火更大。 708C（#） 以你要的点为根，你要让所有子树都&lt;=n/2，如果本身满足就不用操作，否则你需要在&gt;n/2的子树里找到一个&lt;=n/2的最大子树拿出来直接接到根上，如果拿出了这个子树之后就&lt;=n/2了的话就OK。 考虑固定了根怎么求，可以dp，设dp[u]表示u子树里最大的&lt;=n/2的子树，转移就是看所有儿子，如果size不超过n/2就用size转移，否则用dp转移，取个最大值。 只记最大的其实也不行，因为你要换根，换根了之后就要把某个儿子的贡献去掉，所以记最大的和次大的，如果往最大的子树换根则这个点的值变为次大的，否则就是最大的。 767D 一组牛奶可以当且仅当 iii 天内过期的牛奶不超过 k×ik\\times ik×i 瓶。 一定会买保质期最长的若干瓶， 把商店里的牛奶按保质期从大到小排序。 现在考虑到第 xxx 瓶牛奶，维护后面前缀和-k×ik\\times ik×i 的最小值，就能知道这瓶牛奶放不放的下，放不下就结束，否则就放，最小值-1，到下一瓶牛奶更新中间的最小值。 1537F（#） 这种就考虑生成树或二分图。按照经典套路，每次加或减的都是一个偶数，所以如果和的奇偶性不对显然无解。 可以发现，能把两个距离为奇数的位置一个+1一个-1，能把两个距离为偶数的位置都+1/-1。 如果有奇环，因为原图连通，故任意两点都存在长度为奇数/偶数的路径，故一定有解。 如果没有奇环，那么是二分图，那么左部之和减右部之和不变，判断一下即可。 1213F（#） 如果 pl..rp_{l..r}pl..r​ 形成的可重集= ql..rq_{l..r}ql..r​ 形成的可重集，那么可以使用同一种字符来填。 固定了 lll，那么尽量选最小的 rrr，直接贪心往后选，如果相同就分段。 这样可能使得字母不够用，那么把字母比较大的都变成 zzz 即可。 1461E（#） 开始的时候k在[l,r]内。分类讨论。 如果x&gt;=y，一天过后水不会变多，第一天特殊考虑，剩下每一天一定会加水（尽量大，一定不会超过r）。 如果x&lt;y，那么就是一直倒水直到再倒要 &lt;l了，就加水。看上去这种复杂度很高，不过可以发现，再倒要&lt;l的状态只有x种，即l,l+1,…,l+x-1，如果出现环（即状态重复出现）那么就一定能无限进行下去，否则每个状态最多遍历一次，复杂度O(x)。 1477C（#） 如果构造的方案存在钝角∠ABC，那么根据大边对大角，AC一定严格比AB和BC长。 所以如果AB比AC长就不存在这个问题，每次取离A最远的B即可。 1201D 可以发现，最后一定是在一行了里面走，然后向上，再走，再向上。 可以发现一行里停的一定是当前行最左/最右的障碍，你没有必要取完最后一个障碍后还移动，这不如走上去后再移动。 把中间空余的行删去， 然后从下一行到上一行，一种是先往左后往右，一种是先往右后往左， 都计算一下即可。 方便起见在第一行加 (1,1)(1,1)(1,1) 当宝藏。 990E 枚举第 iii 种用来power。 那么你每次为了尽量不重复，一定会选择不超过 now+inow+inow+i 的尽量靠后的非障碍位置。 先判断最长的连续障碍段长度，否则你每个障碍最多回退一步，相当于每次不超过 (n+m)/i(n+m)/i(n+m)/i，可以通过。 1216F 设 dpidp_idpi​ 表示恰好覆盖了不超过 iii 的最小代价。 那么覆盖 iii 应该从 i−ki-ki−k，求 [i−2k−1,i−1][i-2k-1,i-1][i−2k−1,i−1] 的 dpdpdp 最小值转移过来即可（单调队列）。 注意需要 dpdpdp 到 n+kn+kn+k。 1385F 你找到深度最深的（叶子）节点，看它的父亲，如果为叶子的儿子个数 ≥k\\geq k≥k，就删。 如果没有 kkk 个，那么它的父亲就没救了，包括所有儿子无论如何都不行。 1166D（#） 你考虑前缀和，xi=Si−1+rix_i=S_{i-1}+r_ixi​=Si−1​+ri​，那么 Si=2Si−1+riS_i=2S_{i-1}+r_iSi​=2Si−1​+ri​。 那么你要 Sn−1+1&lt;=b&lt;=Sn−1+mS_{n-1}+1&lt;=b&lt;=S_{n-1}+mSn−1​+1&lt;=b&lt;=Sn−1​+m。 你先让 SSS 尽量小，然后再反过来加大，先给 Sn−1S_{n-1}Sn−1​ 加大同时满足条件，把剩下的给 Sn−2S_{n-2}Sn−2​，再不停的往前推。 1583E（#） 根据经典套路先求一棵生成树。询问给路径上的边都+1，这个和路径具体是什么有关系。 考虑设f[u]表示u相邻的边之和的奇偶性，这个和路径具体使什么没关系，一次操作给两端点都异或1。 如果最后存在f是奇数显然无解，否则叶子节点的那些边已经合法，那么推到他们父亲连到父亲的边也合法，一直推可以说明所有的边都合法，即只需要取一棵生成树，合法的依旧合法。 1335F（#） 如果两个机器人走到某一步在同一个格子，那么继续走下去还会在同一个格子。 它要求一直走下去，而走nm步后一定会进入环，所以只需要要求走nm步之后不在同一个格子即可。 现在要求走nm后到哪个位置，这个可以用倍增（也可以对于每个环倒着处理到这个环的点，不带log）。 能到达某个格子的多个位置，如果有黑色尽量选黑色，否则任意选。 1453E 观察一下它走的路径，容易发现进了一棵子树一定是走完了再出来，这个容易归纳证明。 你最后退出时走的那个子树，要增加一些从当前根出去的距离，所以一定是 dpdpdp 最小的子树，子树之间走的一定是最大的。而根节点需要特判，你可以只走次大的，最大的走完直接结束。 650C（#） 同行/同列值相同的位置最终值也会相同，先用并查集并起来形成一个等价类。 现在一行里等价类按照权值小向大连单向边，代表大小关系，可以发现只需要连大小顺序相邻的。 最后需要的步数至少是DAG最长链长度，可以构造每个点的权值为0度点到当前点的最长链的长度达到下界。 623B（#） 还是一样，考虑最后的素因子（每个数都是它的倍数）。 如果一个数不变,+1或-1都不是它的倍数，那么就必须在区间内。 如果有必须在区间内的数，求它们最小和最大的位置，它们之前的一个后缀，之后的一个前缀也可以在区间内，计算一下。否则任意一个数都能在区间内，一个前缀和一个后缀不在区间内，计算一下前缀后缀。 对于原问题，由于不能删完，所以第一个数或最后一个数一定保留，它必须是它们不变,+1,-1中某个的素因子，这样只有两位数种方案，分别判断即可。 1413E（#） 发现如果a&gt;bc，那么他无论怎么恢复都不如减的多，答案是无穷大。 否则a&lt;=bc，不妨假设0时刻你就攻击，到a/b上取整时刻，减的就比加的多了，不如第一个不做。 所以只需要考虑到[(a-1)/b]时刻，那么你一定是能攻击就攻击，在[[(a-1)/b]/d]次操作后达到最大值。 计算一下答案即可。 748D（#） 一定是中间一个回文串（或者没有），然后左边是若干个s，右边是若干个rev(s)。 对于代价和为正的非回文原串和反串一定选，代价和为正的回文原串和反串先选。 最后看看要不要拿掉选的回文串对中的较小值或加入未选回文串的最大值。 912D（#） 显然期望可以拆开，变成期望最大的k个位置的和。 对于(x,y)，能覆盖它的渔网数量=(min(x+r-1,m)-max(x,r)+1)*(min(y+r-1,m)-max(y,r)+1)。 那么两维相对独立，求出(min(x+r-1,m)-max(x,r)+1)的所有x的取值从大到小排，对于y同理。 然后可以使用堆贪心，因为u[1]*v[1]&gt;u[2]*v[1],u[1]*v[1]&gt;u[1]*v[2]，取出前k个即可。 486E（#） 判断一个数能不能在LIS上：求出以每个数为开头/结尾的LIS长度，看看加起来-1是否等于最长的LIS长度。如果等于，那么说明它在LIS上，且位置固定（它一定是LIS上第x个位置）。 判断一个数是不是必须在LIS上：看LIS第x个位置有没有多种选法，如果有就不必须在，否则必须在。 884D 倒过来变成合并，每次把两堆或三堆合并成一堆。 显然合并三堆是更优的（类似三叉哈夫曼树），但是可能合并不完，因为每次是3-&gt;1，减少两个，如果初始有偶数堆最后会剩两堆。 发现不如初始先合并最小的两堆，再做。 1292C 推式子，它这个是个排列， ∑1≤u&lt;v≤nmex⁡(u→v)=∑1≤u&lt;v≤n∑i≥1[mex⁡(u→v)≥i]=∑i≥1∑1≤u&lt;v≤n[mex⁡(u→v)≥i] \\begin{aligned} &amp;\\sum_{1\\leq u\\lt v\\leq n} \\operatorname{mex}(u \\rightarrow v)\\\\ =&amp;\\sum_{1\\leq u\\lt v\\leq n} \\sum_{i\\geq 1} [\\operatorname{mex}(u\\rightarrow v)\\geq i]\\\\ =&amp;\\sum_{i\\geq 1} \\sum_{1\\leq u\\lt v\\leq n} [\\operatorname{mex}(u\\rightarrow v)\\geq i] \\end{aligned} ==​1≤u&lt;v≤n∑​mex(u→v)1≤u&lt;v≤n∑​i≥1∑​[mex(u→v)≥i]i≥1∑​1≤u&lt;v≤n∑​[mex(u→v)≥i]​ 也就是有多少 (u,v)(u,v)(u,v)，使得路径上包含 0..i−10..i-10..i−1 的所有数。 那么首先 0..i−10..i-10..i−1 要在同一条路径上 iii 才可能计算答案。 其次如果固定 iii 满足条件（0..i−10..i-10..i−1 在同一条路径上），那么最理想的方案是两端有一个 i−1i-1i−1，这样到 i−1i-1i−1 可以删去一个数。所以一定是初始有一个 000，然后从小到大，往链两端加入一条权值为 iii 的边，贡献是两端子树大小乘积。 求出这个子树大小，然后倒过来递归，每次删去两端的一端，递归下去。 状态数 O(n2)\\mathcal{O}(n^2)O(n2)，转移 O(1)\\mathcal{O}(1)O(1)，记忆化搜索即可。 1251E1 直接来做 E2。 按照 mim_imi​ 从小到大排序，有个朴素的想法是设 dp[i][j]dp[i][j]dp[i][j] 表示考虑完前 iii 个，i+1..ni+1..ni+1..n 还有 jjj 个被贿赂的最小代价。 转移第一种是 i+1i+1i+1 被贿赂，就转移到 dp[i+1][j−1]+qi+1dp[i+1][j-1]+q_{i+1}dp[i+1][j−1]+qi+1​；第二种是没被贿赂，那么要求 i+j≥mi+1i+j\\geq m_{i+1}i+j≥mi+1​，转移到 dp[i+1][j]dp[i+1][j]dp[i+1][j]。这足以通过 E1。 发现 i+j≥mi+1i+j\\geq m_{i+1}i+j≥mi+1​ 可以移项成为 j≥mi+1−ij\\geq m_{i+1}-ij≥mi+1​−i，也就是一个人跟风为你投票当且仅当后面被贿赂的人数 ≥mi−i+1\\geq m_i-i+1≥mi​−i+1。 把 mim_imi​ 相同的放在一起，倒过来考虑，设当前 ≥mi\\geq m_i≥mi​ 被贿赂的人数为 cnt1cnt1cnt1，&lt;mi&lt;m_i&lt;mi​ 的人数为 cnt2cnt2cnt2，相当于现在一定有 cnt1+cnt2cnt1+cnt2cnt1+cnt2 个人投票，如果够了，那么能全部都选；否则不够，就需要在 ≥mi\\geq m_i≥mi​ 里的再贿赂一些，显然贿赂的越少越好（如果不够之后可以再贿赂），就贿赂直到 cnt1+cnt2cnt1+cnt2cnt1+cnt2 足够，拿个小根堆存一下。 723E（#） 显然度数是奇数的永远不可能合法。 如果只有度数为偶数的点，根据套路，可以考虑欧拉路，恰好有n次进入n次退出。 如果有部分度数为奇数的点，考虑把它们度数也变成偶数，即加一个新点连向所有度数为奇数的点。这样所有度数为偶数的点都合法。 1236D 它的起点在左上角，所以你一定是越绕越小的螺旋形。假如你直走也可以走，右转也可以走，此时你必须直走，因为如果你转弯了，你就再也绕不出来了。 暴力复杂度一定是对的，你每转2次两维必定都减少1。维护一下四个方向的边界，不能超出。最后为了防止不出现没走到的，判断一下走过的格子数量是否为非障碍格子数量。 你找下一个停下的位置，需要二分下一个障碍的左端和方向边界取较小值。 1028D 保证数字互不相同，ACCEPT给你提供了一些信息，即 &lt;x&lt;x&lt;x 的都在 AAA，&gt;x&gt;x&gt;x 的都在 BBB。 维护一定在 AAA 中数字的最大值 uuu 和一定在 BBB 中数字的最小值 vvv，和所有数的 setsetset。 如果ACCEPT的时候问的值比 uuu 小或比 vvv 大，就挂了，没有方案。否则如果这个数 &gt;u&gt;u&gt;u 且 &lt;v&lt;v&lt;v 那么不确定在哪个集合，方案数 ×2\\times 2×2。现在就能更新 u,vu,vu,v 了，uuu 是 &lt;x&lt;x&lt;x 的最大的数，vvv 是 &gt;x&gt;x&gt;x 的最小的数。 结束时还要乘上 u,vu,vu,v 之间的数字个数+1，可以选一个前缀给 AAA，剩下的给 BBB。 618D 从简单的入手讨论。 如果 y≤xy\\leq xy≤x，那肯定尽量走 yyy 边。你发现除了菊花图比较憨憨删去之后直接不连通了，其它情况一定可以都走 yyy。因为你考虑生成树是一个二分图，你如果两部有连边 (u,v)(u,v)(u,v)， 你可以在左边乱跳，然后停在 uuu，再到 vvv，最后在右边乱跳。 所以如果树不是菊花，那么答案是 (n−1)y(n-1)y(n−1)y，否则是 (n−2)y+x(n-2)y+x(n−2)y+x。 如果 x&gt;yx&gt;yx&gt;y，如果你选了 aaa 条 xxx 的路径，那么需要 aaa 条 yyy 把它们接起来。相当于要求树的最小（点）路径覆盖，树形dp即可。 242D（#） 这什么垃圾翻译。。。 和某题差不多，你每次找到一个cnt_i=a_i的，点一下，那么它以后再也不会不合法。 你最多把每个都点一次，所以一定有解。 804C（#） 先给1号点上的所有种类染色。考虑现在到点u，这个点上还有些种类没被染过色。 这些没被染过色的，可以给它们分配和u中染过色不同的，且两两不同的颜色。 尽量分配编号小的颜色，种类数应该是每个点上种类数max，可以发现没有比这样更少的方案。 980E 从大到小贪心，nnn 必须要选。 其它的从大到小贪心，能保留就保留。 保留即路径上的都得保留，判断一下路径上点的数量。 树状数组维护dfs序，删点就直接暴力，树状数组给子树-1。 732E 把电脑扔进multiset，把适配器排序贪心。 具体来说就是枚举除多少次，如果有就和multiset里的配对，删除。 1179C（#） 从大到小枚举最后剩下来的值x看看可不可行，可行当且仅当a_i&gt;=x的个数严格大于b_i&gt;=x的个数。 现在你要带修改，且要快速询问， 保存a_i&gt;=x的个数-b_i&gt;=x的个数，求最靠右的&gt;0的位置。 维护线段树，每次看右儿子的最大值，如果&lt;=0就到左儿子，否则到右儿子。 520D 维护一个大根堆一个小根堆，里面是能拆的方块。 拆了之后向四周扩展，把那些能拆的也加进去。取了的用 map 标记一下。 1616E 这题在现场。先求LCP，如果有前面大于后面就直接输出1. 否则你一定是两种情况之一：替换一个比它小的；替换一个和它一样的。 比它小的直接计算即可，维护后面每种字符的位置；一样的要移过来，维护个vector即可。 1498D（#） 相当于要维护这次操作过后哪些位置能到达。记f[i]为答案。 记g[i]表示这次操作选的a为多少才能到达i，对于之前能到达的i（之后可以一直a=0），g[i]=0。 然后更新，从小到大，g[i]+1-&gt;g[calc(i)]，最后将g[i]&lt;=y的且之前不能到达的i，f[i]更新为当前操作的编号。 622E 显然根的不同子树独立，分开考虑。 如果两个点深度不同，它们是不影响的。 两个深度相同的有交必定会完蛋，所以一定要一个等一秒，相当于深度+1。 所以现在就变成可以给若干个数增加，问全部互不相同时和最小为多少。 排序之后贪心即可。 1190C 先手如果一步就赢那么显然先手必胜。 不能一步就赢，那么后手可以重复先手的操作使局面不变，也可以正常操作，所以要么是平局要么是后手必胜。问题的关键就看后手能不能一步就赢。 枚举先手取的区间，如果左右都相同，那么就可以必胜；否则如果两边都不完全相同，后手一定不可以获胜。如果先手不能必胜且不存在后手不可以必胜，就后手必胜。 1552E（#） 记c=⌈n/(k−1)⌉。 考虑先取出第二次出现位置最小的c个区间，将[第一次,第二次]做为它们的区间。 考虑从剩下的取出第三次出现位置最小的c个区间，将[第二次,第三次]做为它们的区间。 以此类推共取k-1次。可以发现不同组的区间显然两两不交，故一个位置被覆盖的次数最多为c。 1132D 答案显然有可二分性。 你每次一定给最邻近关机的电脑充电，因为你要求所有电脑都不能关机。 用优先队列维护电脑的关机时间，每次给最小的加，如果取出来的时候已经小于当前时间了说明它已经关机了，这个mid不行。 1534E（#） 假设第i个位置在异或中出现了c_i次（c_i必须是奇数）。令sum=Σc_i，则k|sum，c_i&lt;=sum/k。 满足这个当然有解，可以考虑看成矩阵（一行有k个，一列有sum/k个）以列为优先填。 在sum固定的情况下一定是让max{c_i}尽量小，可以变成初始c_i都为1，每次给最小的c_i+=2，看是否满足条件。它说答案不超过500次，最多也就500*k次操作，可以通过。 1148E（#） 首先总和不变。可以把操作看成对于s_j-s_i&gt;=1（=1相当于交换顺序，无关紧要）的两个数，s_j--，s_i++。 对s_i++，s_j--，只要对值相同的取最后/最前的一个，相对顺序就不会改变，说明存在操作使相对顺序不变。 将s,t排序，设a_i=t_i-s_i。现在要把前面的某个-1，后面的某个+1。可以发现有解相当于要求前缀和&gt;0。 具体的构造方法类似于括号序，看栈底和当前数的大小关系即可。 909D 直接暴力复杂度是平方的。容易想到把同颜色当成一个同色段。 左右的同色段每次长度减少1，中间的同色段每次长度减少2（左右都没了）。 可以暴力，因为每个点只会消失一次，所以可以直接暴力给每个段长度 −1/−2-1/-2−1/−2，如果减没了直接暴力合并，复杂度为 O(n)O(n)O(n)。 576B（#） 首先树相同必须重心相同，一棵树最多有两个重心，说明必须存在一个&lt;=2的循环。 如果存在不动点即p_i=i，可以造一个以i为根的菊花。 否则存在对换p_a=b,p_b=a，考虑断开a,b的边，那么发现两部分排列后将会变成对方。 所以如果存在长度为奇数的循环则无解。否则将循环上奇数位置连a，偶数位置连b即可。 496E 由于 aj≤bja_j\\leq b_jaj​≤bj​，所以可以把条件改为 −aj≤−ci,bj≤di-a_j\\leq -c_i,b_j\\leq d_i−aj​≤−ci​,bj​≤di​。 把演奏家按照 (−ci,di)(-c_i,d_i)(−ci​,di​) 的二元组排序，按照顺序，你一定是取 −aj≤−ci,bj≤di-a_j\\leq -c_i,b_j\\leq d_i−aj​≤−ci​,bj​≤di​ 中 bjb_jbj​ 最大的，因为之后的 −ci-c_i−ci​ 都不比当前的小，所以你只需要尽量的取 bib_ibi​ 大的。 229D 题目相当于分成若干个段，使得每段和不降，问n-最小段数。 设 fif_ifi​ 为 1..i1..i1..i 不降的最少段数，hih_ihi​ 为此时最后一个塔的最小高度。 有一个直观的想法：存在一种答案最小的方案，最后一个数也是最小的。 这个怎么证明呢，假设 1..i−11..i-11..i−1 都满足，那么 hhh 存的就是可能的最小高度。fif_ifi​ 的转移即为 fi=min⁡j&lt;i,hj≤sum(j+1,i){fj−j}+i−1f_i=\\min_{j&lt;i,h_j\\leq sum(j+1,i)} \\{f_j-j\\}+i-1 fi​=j&lt;i,hj​≤sum(j+1,i)min​{fj​−j}+i−1 这个形式不好看，设 gig_igi​ 为 fi−if_i-ifi​−i。 gi=min⁡j&lt;i,hj≤sum(j+1,i){gj}−1g_i=\\min_{j&lt;i,h_j\\leq sum(j+1,i)} \\{g_j\\}-1 gi​=j&lt;i,hj​≤sum(j+1,i)min​{gj​}−1 由于 gi−1g_{i-1}gi−1​ 可以转移的 jjj 在 gig_igi​ 也可以转移，所以 gi−1≥gig_{i-1}\\geq g_igi−1​≥gi​。所以你找到最大的满足条件的 jjj，它的 ggg 一定是最小的，同时 hhh 也是 sum(j+1,i)sum(j+1,i)sum(j+1,i)，即证明了 iii 也满足条件。 问题变成怎么找这个 jjj，j&lt;i,hj+prej≤preij&lt;i,h_j+pre_j\\leq pre_ij&lt;i,hj​+prej​≤prei​，而这个 preipre_iprei​ 也是单调递增的，故可以维护一个单调（hj+prejh_j+pre_jhj​+prej​ 递增）队列。 269C（#） 非源非汇的点流量平衡。 由于最后是DAG，考虑一个类似于拓扑排序的做法。 首先入度为0的应该是1号点和无边相连的点。 那么加入队列的，没访问的邻边都是出边，更新一下，看看另一端能不能加入队列。 1603C 如果你知道一个数最后分成了x个，那么一定是尽量平均的分配（设y=val mod x，则有x-y个u和y个u+1，其中u=[val/x]，无论怎么调整都不能使最大值减小或最小值增大）。 考虑怎么求整个序列的值，这就显而易见了，你从右往左，每次求最少操作几次，使得值不超过右边的数的值即可。 但是，你一个数拆分是整除的形式，即这个u只有sqrt V种，当前数尽量大，转移一下即可。 995C（#） 原来每个不超过1e6，最后要求和不超过1.5e6。 向量相加显然和夹角有关系，考虑哪些夹角可以。 c2=a2+b2-2abcosC，不妨设a&lt;=b，那么c2&lt;=a2(1-2cosC)+b2，当cosC&lt;=1/2时c2&lt;=b2。 （这个是把两个向量首尾相接，形成三角形两条边）。 拿出三个向量，正反有6个向量，一定有两个夹角&lt;=pi/3，满足条件。 到最后只剩下两个向量时，夹角之间&lt;=pi/2，这样长度可能乘上sqrt(2)，也不超过1.5e6。 1217E（#） 有个简单的思路，平衡的是不是每一位最多只有一个数非0。 思考一下，发现如果有多个数某位都非0，且还要满足条件，那么一定需要进位。 对于前面的位，如果后面有进位，要满足条件自己也要进位。 到最后会进到一个没有数出现过的位，就gg了。 那么不平衡的一定有两个数在某一位都非0，要求最小就是这一位非0的最小的两个数之和。 线段树记录一下区间每一位非0的数中，最小和次小的值即可。 1158C（#） 先考虑没有-1的情况，存在i,j，i&lt;j&lt;nxt_i&lt;nxt_j一定无解。否则可以构造出解。 对于后缀最大值（nxt_i=n+1），它们之间的小区间又是独立的（nxt_j&lt;=i），递归下去做。 具体实现可以类似于建树，i的父亲是nxt_i，层数低的比层数高的值大，同层编号小的比编号大的值大。 nxt_i=-1的情况，直接取nxt_i=i+1即可，这样不会使得原来有解的变成无解。 ","link":"https://hydd-new.github.io/tan-xin/"},{"title":"NOIP2021 方差","content":"考场30min完成前面两题，就一直想调整，打表，花了好几个小时。 我当时也在想，估计要找能到达的集合有什么规律，但就是找不到。 在调整和打表找规律反复横跳，然后就自闭了。 na‾=∑i=1nain2D=n∑i=1n(ai−a‾)2=n∑i=1nai2−2na‾∑i=1nai+n2a‾2=n∑i=1nai2−2(∑i=1nai)2+(∑i=1nai)2=n∑i=1nai2−(∑i=1nai)2\\begin{aligned} n\\overline{a}&amp;=\\sum_{i=1}^na_i\\\\ \\\\ n^2D &amp;=n\\sum_{i=1}^n(a_i-\\overline{a})^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-2n\\overline{a}\\sum_{i=1}^n a_i+n^2\\overline{a}^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-2(\\sum_{i=1}^n a_i)^2+(\\sum_{i=1}^n a_i)^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-(\\sum_{i=1}^n a_i)^2\\\\ \\end{aligned} nan2D​=i=1∑n​ai​=ni=1∑n​(ai​−a)2=ni=1∑n​ai2​−2nai=1∑n​ai​+n2a2=ni=1∑n​ai2​−2(i=1∑n​ai​)2+(i=1∑n​ai​)2=ni=1∑n​ai2​−(i=1∑n​ai​)2​ 观察题目中的式子，ai′←ai−1+ai+1−aia&#x27;_i\\leftarrow a_{i-1}+a_{i+1}-a_iai′​←ai−1​+ai+1​−ai​，根据 CF1110E 的套路，可以差分，令 di=ai+1−ai(1≤i&lt;n)d_i=a_{i+1}-a_i(1\\leq i\\lt n)di​=ai+1​−ai​(1≤i&lt;n)，一次操作 (2≤i&lt;n)(2\\leq i\\lt n)(2≤i&lt;n) 即： di−1′=ai′−ai−1′=(ai−1+ai+1−ai)−ai−1=ai+1−ai=didi′=ai+1′−ai′=ai+1−(ai−1+ai+1−ai)=ai−ai−1=di−1d&#x27;_{i-1}=a&#x27;_{i}-a&#x27;_{i-1}=(a_{i-1}+a_{i+1}-a_i)-a_{i-1}=a_{i+1}-a_i=d_i\\\\ d&#x27;_i=a&#x27;_{i+1}-a&#x27;_{i}=a_{i+1}-(a_{i-1}+a_{i+1}-a_i)=a_i-a_{i-1}=d_{i-1} di−1′​=ai′​−ai−1′​=(ai−1​+ai+1​−ai​)−ai−1​=ai+1​−ai​=di​di′​=ai+1′​−ai′​=ai+1​−(ai−1​+ai+1​−ai​)=ai​−ai−1​=di−1​ 相当于交换 di−1,di(2≤i&lt;n)d_{i-1},d_i(2\\leq i\\lt n)di−1​,di​(2≤i&lt;n)，故 ddd 可以通过若干次操作，变为任意 ddd 的排列。 由于 a1a_1a1​ 不变，那么 aaa 和 ddd 是一一对应的。现在要求一个 ddd 的排列使得 n2Dn^2Dn2D 最小，继续推式子： n2D=n∑i=1nai2−(∑i=1nai)2=n∑i=1nai2−∑i=1n∑j=1naiaj=12(n∑i=1nai2−2∑i=1n∑j=1naiaj+n∑j=1naj2)=12(∑i=1n∑j=1n(ai−aj)2)=∑i=1n−1∑j=in−1(aj+1−ai)2=∑i=1n−1∑j=in−1(di+di+1+⋯+dj)2\\begin{aligned} n^2D &amp;=n\\sum_{i=1}^n a_i^2-(\\sum_{i=1}^n a_i)^2\\\\ &amp;=n\\sum_{i=1}^n a_i^2-\\sum_{i=1}^n\\sum_{j=1}^na_ia_j\\\\ &amp;=\\frac{1}{2}(n\\sum_{i=1}^n a_i^2-2\\sum_{i=1}^n\\sum_{j=1}^na_ia_j+n\\sum_{j=1}^n a_j^2)\\\\ &amp;=\\frac{1}{2}(\\sum_{i=1}^n\\sum_{j=1}^n(a_i-a_j)^2)\\\\ &amp;=\\sum_{i=1}^{n-1}\\sum_{j=i}^{n-1}(a_{j+1}-a_i)^2\\\\ &amp;=\\sum_{i=1}^{n-1}\\sum_{j=i}^{n-1}(d_i+d_{i+1}+\\cdots+d_j)^2\\\\ \\end{aligned} n2D​=ni=1∑n​ai2​−(i=1∑n​ai​)2=ni=1∑n​ai2​−i=1∑n​j=1∑n​ai​aj​=21​(ni=1∑n​ai2​−2i=1∑n​j=1∑n​ai​aj​+nj=1∑n​aj2​)=21​(i=1∑n​j=1∑n​(ai​−aj​)2)=i=1∑n−1​j=i∑n−1​(aj+1​−ai​)2=i=1∑n−1​j=i∑n−1​(di​+di+1​+⋯+dj​)2​ n2Dn^2Dn2D 取最小值时，ddd 一定是先递减后递增的。 考虑在分界位置（即递减到递增）从小到大往两边加数，由于 n2D=n∑i=1nai2−(∑i=1nai)2\\begin{aligned} n^2D &amp;=n\\sum_{i=1}^n a_i^2-(\\sum_{i=1}^n a_i)^2\\\\ \\end{aligned} n2D​=ni=1∑n​ai2​−(i=1∑n​ai​)2​ 维护 dp[k][s]dp[k][s]dp[k][s] 表示当前已经加入了 kkk 个数，现在的 aaa 之和为 sss 的最小 ∑i=1nai2\\displaystyle \\sum_{i=1}^n a_i^2i=1∑n​ai2​。 初始 dp[1][s]=0dp[1][s]=0dp[1][s]=0。 转移时考虑加到左边还是右边： 左边：原来是 a1,a2,⋯ ,aka_1,a_2,\\cdots,a_ka1​,a2​,⋯,ak​，现在变为 d,a1+d,a2+d,⋯ ,ak+dd,a_1+d,a_2+d,\\cdots,a_k+dd,a1​+d,a2​+d,⋯,ak​+d，新增的贡献为 Δ=d2+∑i=1k(d+ai)2−∑i=1kai2=(k+1)d2+2d∑i=1kai=(k+1)d2+2ds\\begin{aligned} \\Delta &amp;=d^2+\\sum_{i=1}^k (d+a_i)^2-\\sum_{i=1}^k a_i^2\\\\ &amp;=(k+1)d^2+2d\\sum_{i=1}^ka_i\\\\ &amp;=(k+1)d^2+2ds\\\\ \\end{aligned} Δ​=d2+i=1∑k​(d+ai​)2−i=1∑k​ai2​=(k+1)d2+2di=1∑k​ai​=(k+1)d2+2ds​ 右边：原来是 a1,a2,⋯ ,aka_1,a_2,\\cdots,a_ka1​,a2​,⋯,ak​，现在变为 a1,a2,⋯ ,ak,ak+da_1,a_2,\\cdots,a_k,a_k+da1​,a2​,⋯,ak​,ak​+d，新增的贡献为Δ=(ak+d)2\\begin{aligned} \\Delta &amp;=(a_k+d)^2\\\\ \\end{aligned} Δ​=(ak​+d)2​ 其实可以发现 aka_kak​ 是固定的，为之前所有的 ddd 之和，不需要再记录。 答案为 min⁡s{n×dp[n][s]−s2}\\displaystyle \\min_s\\{n\\times dp[n][s]-s^2\\}smin​{n×dp[n][s]−s2}。 分析一下时间复杂度，第一维是 O(n)O(n)O(n) 的，第二维是 O(nV)O(nV)O(nV) 的，转移 O(1)O(1)O(1)。 但是可以发现 ddd 为 000 的转移可以忽略，第一维是 O(min⁡(n,V))O(\\min(n,V))O(min(n,V)) 的，总复杂度为 O(nV2)O(nV^2)O(nV2)，可以通过。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF=1ll&lt;&lt;60; int n,a[11000],d[11000]; ll dp[510000]; ll sqr(ll x){ return x*x;} int main(){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for (int i=1;i&lt;n;i++) d[i]=a[i+1]-a[i]; sort(d+1,d+n); for (int i=0;i&lt;=500000;i++) dp[i]=INF; dp[0]=0; int lim=0,sum=0; for (int i=1;i&lt;n;i++){ if (!d[i]) continue; for (int s=lim;s&gt;=0;s--){ if (dp[s]==INF) continue; dp[s+sum+d[i]]=min(dp[s+sum+d[i]],dp[s]+sqr(sum+d[i])); dp[s+i*d[i]]=min(dp[s+i*d[i]],dp[s]+2*s*d[i]+i*sqr(d[i])); dp[s]=INF; } lim+=i*d[i]; sum+=d[i]; } ll ans=INF; for (int i=0;i&lt;=lim;i++) if (dp[i]!=INF) ans=min(ans,n*dp[i]-1ll*i*i); printf(&quot;%lld\\n&quot;,ans); return 0; } ","link":"https://hydd-new.github.io/NOIP21T3/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hydd-new.github.io/hello-gridea/"}]}